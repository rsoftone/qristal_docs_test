<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Examples &mdash; Quantum SDK  documentation</title>
      <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../_static/collapsible-lists/css/tree_view.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script async="async" src="https://www.googletagmanager.com/gtag/js?id=G-215J15FW78"></script>
        <script src="../_static/js/qb_ga.js"></script>
        <script src="../_static/collapsible-lists/js/CollapsibleLists.compressed.js"></script>
        <script src="../_static/collapsible-lists/js/apply-collapsible-lists.js"></script>
        <script>window.MathJax = {"options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
        <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../index.html" class="icon icon-home">
            Quantum SDK
              <img src="../_static/qb_logo.png" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Basic Usage</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../rst/getting_started.html">Getting started</a></li>
<li class="toctree-l1"><a class="reference internal" href="../rst/examples.html">Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="../rst/cli.html">Command-line interface</a></li>
<li class="toctree-l1"><a class="reference internal" href="../rst/quantum_computing.html">Quantum Computing</a></li>
<li class="toctree-l1"><a class="reference internal" href="../rst/noise_models.html">Noise models</a></li>
<li class="toctree-l1"><a class="reference internal" href="../rst/noise_models.html#user-defined-noise-models">User defined noise models</a></li>
<li class="toctree-l1"><a class="reference internal" href="../rst/vqe.html">Variational Quantum Eigensolver (VQE)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../rst/qml.html">Quantum Machine Learning (QML)</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Source Code Documentation</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../_cpp_api/library_root.html">C++ API</a></li>
<li class="toctree-l1"><a class="reference internal" href="../rst/python_autodoc.html">Python API</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Quantum SDK</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">Examples</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/md/examples.md.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section class="tex2jax_ignore mathjax_ignore" id="examples">
<h1>Examples<a class="headerlink" href="#examples" title="Permalink to this headline"></a></h1>
<p>The <code class="docutils literal notranslate"><span class="pre">examples</span></code> folder contains a series of example C++ and Python main programs.</p>
<p>After installing the core (<code class="docutils literal notranslate"><span class="pre">make</span> <span class="pre">install</span></code> in the main project build folder of either the core or SDK), the Python programs can be run by simply invoking</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">python3</span><span class="w"> </span><span class="o">&lt;</span><span class="n">name_of_example</span><span class="o">&gt;</span><span class="p">.</span><span class="n">py</span>
</pre></div>
</div>
<p>The C++ examples are installed as source files with working CMakeLists.txt build scripts, to demonstrate how to use the core library to build your own C++ main program. To build and run an example in the installation directory, do</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">cd</span><span class="w"> </span><span class="o">&lt;</span><span class="n">Qristal_installation_directory</span><span class="o">&gt;</span>
<span class="n">mkdir</span><span class="w"> </span><span class="n">build</span>
<span class="n">cd</span><span class="w"> </span><span class="n">build</span>
<span class="n">cmake</span><span class="w"> </span><span class="p">..</span><span class="o">/</span><span class="n">examples</span><span class="o">/</span><span class="n">cpp</span><span class="o">/&lt;</span><span class="n">name_of_example</span><span class="o">&gt;</span>
<span class="n">make</span>
<span class="p">.</span><span class="o">/&lt;</span><span class="n">name_of_example</span><span class="o">&gt;</span>
</pre></div>
</div>
<p>The C++ example programs are <em>also</em> built and properly linked automatically when running <code class="docutils literal notranslate"><span class="pre">make</span> <span class="pre">install</span></code> in the build folder of the core and SDK projects, but the resulting binaries are <em>not</em> installed.  They simply appear in the main project build folder, and can be executed directly from there.</p>
<p>A description of the available gates and the syntax used to implement them in Python is given in the <a class="reference external" href="https://qristal.readthedocs.io/en/latest/rst/quantum_computing.html">Quantum Computing</a> section.</p>
<section id="python">
<h2>Python<a class="headerlink" href="#python" title="Permalink to this headline"></a></h2>
<p><code class="docutils literal notranslate"><span class="pre">demo1.py</span></code></p>
<p><em>qubits</em>: 2<br />
<em>gate depth</em>: 3<br />
<em>noise</em>: false</p>
<p>A simple example showing a 2 qubit circuit consisting of just a Hadamard and a regular 1-qubit NOT gate.</p>
<p><code class="docutils literal notranslate"><span class="pre">quickstart.py</span></code></p>
<p><em>qubits</em>: 2<br />
<em>gate depth</em>: 6<br />
<em>noise</em>: false</p>
<p>The 2-qubit Bell state quickstart example given in the README of the main project.</p>
<p><code class="docutils literal notranslate"><span class="pre">aer_simulator/aer_mps_simple.py</span></code></p>
<p><em>qubits</em>: 2<br />
<em>gate depth</em>: 6<br />
<em>noise</em>: true</p>
<p>Example usage of the aer matrix-product-state-based simulator for computing a 2-qubit Bell state circuit.</p>
<p><code class="docutils literal notranslate"><span class="pre">aer_simulator/aer_mps_dj_large.py</span></code></p>
<p><em>qubits</em>: 41<br />
<em>gate depth</em>: 204<br />
<em>noise</em>: true</p>
<p>Example usage of the aer matrix-product-state-based simulator for computing a larger Deutsch-Jozsa circuit.  This example may take some time to run.</p>
<p><code class="docutils literal notranslate"><span class="pre">amcu.py</span></code></p>
<p><em>qubits</em>: 5<br />
<em>gate depth</em>: 3392<br />
<em>noise</em>: false</p>
<p>Stands for “ancilla multi-controlled unitary” and is a Python binding of <code class="docutils literal notranslate"><span class="pre">MultiControlledUWithAncilla</span></code>. Performs a multi-controlled unitary operator U on the target qubit conditioned on the controlled qubits. In this example, the unitary U is defined to be the x gate. The control qubits are first encoded with the bitstring[j] = 1. Ancilla qubits act as scratch qubits used to check whether the desired condition is met, i.e. the jth control qubit is equal to 1. Once the condition is met, the target qubit is flipped by U.</p>
<p><code class="docutils literal notranslate"><span class="pre">amplitude_amplification/amp_amplification.py</span></code></p>
<p><em>qubits</em>: 3<br />
<em>gate depth</em>: 111<br />
<em>noise</em>: false</p>
<p>A simple amplitude amplification example using Grover’s algorithm, targeting the state <span class="math notranslate nohighlight">\(\ket{111}\)</span>.</p>
<p><code class="docutils literal notranslate"><span class="pre">amplitude_amplification/amplitude_amplification.py</span></code></p>
<p><em>qubits</em>: 3<br />
<em>gate depth</em>: 371<br />
<em>noise</em>: false</p>
<p>A slightly more complex example of amplitude amplification using Grover’s algorithm, targeting the <span class="math notranslate nohighlight">\(\ket{101} - \ket{011}\)</span> state. This example may take some time to run.</p>
<p><code class="docutils literal notranslate"><span class="pre">amplitude_amplification/amp_amplification_iteration.py</span></code></p>
<p><em>qubits</em>: 1<br />
<em>gate depth</em>: 6318<br />
<em>noise</em>: false</p>
<p>A demonstration of iterative amplitude amplification of the <span class="math notranslate nohighlight">\(\ket{1}\)</span> state.  Requires <code class="docutils literal notranslate"><span class="pre">matplotlib</span></code> and outputs a plot of the results named <code class="docutils literal notranslate"><span class="pre">qaa.png</span></code>.</p>
<p><code class="docutils literal notranslate"><span class="pre">amplitude_estimation/canonical_amplitude_estimation.py</span></code></p>
<p><em>qubits</em>: 1 + number of precision qubits (user defined)<br />
<em>noise</em>: false</p>
<p>An implementation of the canonical amplitude estimation example described <a class="reference external" href="https://qiskit.org/documentation/finance/tutorials/00_amplitude_estimation.html">here</a>, implemented by constructing the required Grover operator.</p>
<p><code class="docutils literal notranslate"><span class="pre">amplitude_estimation/canonical_amplitude_estimation_oracle.py</span></code></p>
<p><em>qubits</em>: 9<br />
<em>noise</em>: false</p>
<p>An implementation of the canonical amplitude estimation example described <a class="reference external" href="https://qiskit.org/documentation/finance/tutorials/00_amplitude_estimation.html">here</a>, implemented by passing the desired oracle. This example may take some time to run.</p>
<p><code class="docutils literal notranslate"><span class="pre">amplitude_estimation/methods_comparison.py</span></code></p>
<p><em>qubits</em>: 11<br />
<em>noise</em>: false</p>
<p>Compares the results and runtimes of canonical and maximum likelihood amplitude estimation.</p>
<p><code class="docutils literal notranslate"><span class="pre">amplitude_estimation/ML_amplitude_estimation.py</span></code></p>
<p><em>qubits</em>: 1<br />
<em>noise</em>: false</p>
<p>Example demonstrating maximum likelihood amplitude estimation (MLQAE) as described <a class="reference external" href="https://qiskit.org/documentation/finance/tutorials/00_amplitude_estimation.html">here</a>.</p>
<p><code class="docutils literal notranslate"><span class="pre">amplitude_estimation/ML_amplitude_estimation_parameter_testing.py</span></code></p>
<p><em>qubits</em>: 1<br />
<em>noise</em>: false</p>
<p>As per <code class="docutils literal notranslate"><span class="pre">ML_amplitude_estimation.py</span></code>, but repeated for different numbers of runs and shots.  Requires <code class="docutils literal notranslate"><span class="pre">matplotlib</span></code> and outputs a plot of the results named <code class="docutils literal notranslate"><span class="pre">MLQAE_parameter_test.png</span></code>.</p>
<p><code class="docutils literal notranslate"><span class="pre">amplitude_estimation/MLQAE_parameter_scaling.py</span></code></p>
<p><em>qubits</em>: 15<br />
<em>noise</em>: false</p>
<p>As per <code class="docutils literal notranslate"><span class="pre">ML_amplitude_estimation_parameter_testing.py</span></code>, but repeated for different numbers of qubits.  Also offers an internal option to perform the same parameter scan for canonical amplitude estimation. This example requires matplotlib and produces a series of plots named <code class="docutils literal notranslate"><span class="pre">MLQAE_parameter_test_*_qubits.png</span></code>.  It may take some time to run.</p>
<p><code class="docutils literal notranslate"><span class="pre">async_example_1.py</span></code></p>
<p><em>qubits</em>: 2<br />
<em>gate depth</em>: 6<br />
<em>noise</em>: false</p>
<p>An example of asynchronous circuit execution, using 32 workers to perform 200 circuit executions.</p>
<p><code class="docutils literal notranslate"><span class="pre">async_example_2.py</span></code></p>
<p><em>qubits</em>: 2<br />
<em>gate depth</em>: 6<br />
<em>noise</em>: false</p>
<p>An example of asynchronous circuit execution, using 32 workers to perform 3200 circuit executions.</p>
<p><code class="docutils literal notranslate"><span class="pre">comparator.py</span></code></p>
<p><em>qubits</em>: 9 (comparator), 2 (comparator_as_oracle)<br />
<em>gate depth</em>: 226 (comparator), 113 (comparator_as_oracle)<br />
<em>noise</em>: false</p>
<p>Example comparing whether two bitstrings/registers are equivalent.</p>
<p><code class="docutils literal notranslate"><span class="pre">compare_beam_oracle.py</span></code></p>
<p><em>qubits</em>: 11<br />
<em>gate depth</em>: 238<br />
<em>noise</em>: false</p>
<p>This calls a quantum decoder-specific module. Example to check whether a string (<span class="math notranslate nohighlight">\(S_A\)</span>) is equal to a string of ones <span class="math notranslate nohighlight">\(\ket{11 \ldots 1}\)</span>. This module is used in the quantum decoder kernel algorithm. The registers of flags, <span class="math notranslate nohighlight">\(F_A\)</span> and <span class="math notranslate nohighlight">\(F_B\)</span> are initialised as <span class="math notranslate nohighlight">\(\ket{1}\)</span>. Then they are turned off if the symbol is neither null or repetition flagged. Therefore the symbols in <span class="math notranslate nohighlight">\(S_{A}\)</span> will be flagged in <span class="math notranslate nohighlight">\(F_{A/B}\)</span> if and only if they are null or repeated or both. Once this flagging is done, the oracle flag <span class="math notranslate nohighlight">\(q_0\)</span> returns 1 true if and only if 1. corresponding symbols are either both flagged or both unflagged, and 2. if both unflagged then the symbols must match.</p>
<p><code class="docutils literal notranslate"><span class="pre">compare_gt.py</span></code></p>
<p><em>qubits</em>: 12<br />
<em>gate depth</em>: 244<br />
<em>noise</em>: false</p>
<p>Example comparing whether the value of bitstring/register <span class="math notranslate nohighlight">\(A\)</span> is greater than the value of bitstring/register <span class="math notranslate nohighlight">\(B\)</span>.</p>
<p><code class="docutils literal notranslate"><span class="pre">controlled_addition.py</span></code></p>
<p><em>qubits</em>: 7<br />
<em>gate depth</em>: 343<br />
<em>noise</em>: false</p>
<p>Example demonstrating adding two numbers condition on the the flag qubit being on or off. If the flag qubit is on (off), the the addition is (is not) performed.</p>
<p><code class="docutils literal notranslate"><span class="pre">controlled_subtraction.py</span></code></p>
<p><em>qubits</em>: 10<br />
<em>noise</em>: false</p>
<p>Example demonstrating subtracting two numbers condition on the the flag qubit being on or off. If the flag qubit is on (off), the the subtraction is (is not) performed. This example takes a very long time to complete.</p>
<p><code class="docutils literal notranslate"><span class="pre">controlled_swap.py</span></code></p>
<p><em>qubits</em>: 10<br />
<em>gate depth</em>: 685<br />
<em>noise</em>: false</p>
<p>Example performing a swap operation conditioned on the alphabet is “b”. If the given alphabet is “b”, then a swap operation is performed to move the given alphabet to the end of the string. This example starts with a string “babba” and returns “aabbb”.</p>
<p><code class="docutils literal notranslate"><span class="pre">cpfd.py</span></code></p>
<p><em>qubits</em>: 13<br />
<em>noise</em>: false</p>
<p>Stands for “controlled proper fraction division”. Given two registers A and B, this module performs the division between the value of A and the value of B. The example performs every 3-qubit proper fraction division with 3 precision bits. This example takes a very long time to complete.</p>
<p><code class="docutils literal notranslate"><span class="pre">efficient_encoding.py</span></code></p>
<p><em>qubits</em>: 14<br />
<em>gate depth</em>: 3392 (with ancilla), 10245 (without ancilla)<br />
<em>noise</em>: false</p>
<p>This calls the EfficientEncoding module to perform a simple encoding using Gray code flips. This example takes the input <span class="math notranslate nohighlight">\(\ket{i}\ket{i}\)</span> with three qubits in each register and returns all possible configurations of the two three-qubit registers <span class="math notranslate nohighlight">\(\ket{000}\ket{000} + \ldots + \ket{111}\ket{111}\)</span>.</p>
<p><code class="docutils literal notranslate"><span class="pre">equality_checker.py</span></code></p>
<p><em>qubits</em>: 9 (with ancilla), 7 (without ancilla)<br />
<em>gate depth</em>: 106 (with ancilla), 92 (without ancilla)<br />
<em>noise</em>: false</p>
<p>Example checking for equality between the values of two registers. The flag qubit returns 1 (0) if the values are equal (unequal).</p>
<p><code class="docutils literal notranslate"><span class="pre">exponential_search.py</span></code></p>
<p>Example demonstrating the use of the exponential search algorithm to find the largest number, or “best score”, in a dataset. If sufficient search iterations are done, the algorithm should return the best score of 3.</p>
<p><code class="docutils literal notranslate"><span class="pre">generalised_mcx.py</span></code></p>
<p><em>qubits</em>: 3<br />
<em>gate depth</em>: 46<br />
<em>noise</em>: false</p>
<p>Example performing a generalized MCX gate on all possible 3-qubit bit strings (<span class="math notranslate nohighlight">\(\ket{000}, \ldots, \ket{111}\)</span>) with all combinations of control qubit conditions ((on,on), <span class="math notranslate nohighlight">\(\ldots\)</span> , (off,off)).</p>
<p><code class="docutils literal notranslate"><span class="pre">mcx.py</span></code></p>
<p><em>qubits</em>: 3<br />
<em>gate depth</em>: 46<br />
<em>noise</em>: false</p>
<p>Example of performing an MCX operation on all possible 3-qubit strings (<span class="math notranslate nohighlight">\(\ket{000}, \ldots, \ket{111}\)</span>). The target qubit is flipped if the <span class="math notranslate nohighlight">\(i\)</span>th bitstring/control qubit is equal to 1.</p>
<p><code class="docutils literal notranslate"><span class="pre">multiplication.py</span></code></p>
<p><em>qubits</em>: 9<br />
<em>gate depth</em>: 686<br />
<em>noise</em>: false</p>
<p>Example of a multiplication of values encoded in registers <span class="math notranslate nohighlight">\(\ket{a}\)</span> and <span class="math notranslate nohighlight">\(\ket{b}\)</span>.</p>
<p><code class="docutils literal notranslate"><span class="pre">noise_mitigation.py</span></code></p>
<p><em>qubits</em>: 2<br />
<em>gate depth</em>: 6<br />
<em>noise</em>: true</p>
<p>This example shows the effects of various noise mitigation strategies available in Qristal, using a noisy 2-qubit Bell state.</p>
<p><code class="docutils literal notranslate"><span class="pre">noise_model.py</span></code></p>
<p><em>qubits</em>: 2
<em>gate depth</em>: 6
<em>noise</em>: true</p>
<p>A version of <code class="docutils literal notranslate"><span class="pre">quickstart.py</span></code> with noise.</p>
<p><code class="docutils literal notranslate"><span class="pre">noise_model_user_defined.py</span></code></p>
<p><em>qubits</em>: 2
<em>gate depth</em>: 6
<em>noise</em>: true</p>
<p>A version of <code class="docutils literal notranslate"><span class="pre">noise_model.py</span></code> demonstrating the use of a user-defined noise model.</p>
<p><code class="docutils literal notranslate"><span class="pre">noise_model_user_defined_qb_gateset.py</span></code></p>
<p><em>qubits</em>: 2
<em>gate depth</em>: 6
<em>noise</em>: true</p>
<p>A version of <code class="docutils literal notranslate"><span class="pre">noise_model_user_defined.py</span></code> demonstrating the use of a user-defined noise model in a different basis gate set.</p>
<p><code class="docutils literal notranslate"><span class="pre">pfd.py</span></code></p>
<p><em>qubits</em>: 12<br />
<em>gate depth</em>: 4690<br />
<em>noise</em>: false</p>
<p>Example of proper fraction division. This example performs every 3-qubit proper fraction division with 3 precision bits.</p>
<p><code class="docutils literal notranslate"><span class="pre">qaoa_example.py</span></code></p>
<p><em>qubits</em>: 5<br />
<em>noise</em>: false</p>
<p>Demonstrates the use of Qristal’s built-in implementation of the QAOA algorithm. This example may take some time to run.</p>
<p><code class="docutils literal notranslate"><span class="pre">qaoa_API_demo.py</span></code></p>
<p><em>qubits</em>: 9<br />
<em>noise</em>: false</p>
<p>Demonstrates the use of the QAOA and QUBO APIs at a QAP problem. This example may take some time to run.</p>
<p><code class="docutils literal notranslate"><span class="pre">qft.py</span></code></p>
<p><em>qubits</em>: 5<br />
<em>noise</em>: false</p>
<p>Example of a quantum Fourier transform.</p>
<p><code class="docutils literal notranslate"><span class="pre">qml/RDBMS_query_optimization.py</span></code></p>
<p><em>qubits</em>: 4
<em>variational_params</em>: 40
<em>noise</em>: false</p>
<p>Example showing QML wrapped in PyTorch for optimizing the join order of tables for reduced query latency in relational database management systems (such as PostgreSQL).</p>
<p><code class="docutils literal notranslate"><span class="pre">qpe.py</span></code></p>
<p><em>qubits</em>: 5<br />
<em>gate depth</em>: 16<br />
<em>noise</em>: false</p>
<p>Example of a quantum phase estimation, <span class="math notranslate nohighlight">\(\hat{O}\ket{\psi} = e^{i\phi}\ket{\psi}\)</span>, where the goal is to estimate the phase <span class="math notranslate nohighlight">\(\phi\)</span>. The oracle operator <span class="math notranslate nohighlight">\(\hat{O}\)</span> in this case is a general <span class="math notranslate nohighlight">\(U1\)</span> rotation, i.e. <span class="math notranslate nohighlight">\(U1(\theta) \ket{1} = e^{i\theta}\ket{1}\)</span>. Test value: <span class="math notranslate nohighlight">\(-5\pi/8\)</span>.</p>
<p><code class="docutils literal notranslate"><span class="pre">qsim_noisy.py</span></code></p>
<p><em>qubits</em>: 3<br />
<em>gate depth</em>: 46<br />
<em>noise</em>: true</p>
<p>A generalized mcx gate operates on a target qubit in the state <span class="math notranslate nohighlight">\(\ket{1}\)</span> conditioned on 2 control qubits in the state <span class="math notranslate nohighlight">\(\ket{11}\)</span>. This flips the target qubit to <span class="math notranslate nohighlight">\(\ket{0}\)</span>.  The basic version of the example does not include noise. If you have the Qristal Emulator installed, two lines in the example file can be uncommented to convert it into an example of a simulation in a noisy environment, using noise models provided by the emulator. Details about the noise model are available <a class="reference external" href="https://qristal.readthedocs.io/en/latest/rst/noise_models.html">here</a> .</p>
<p><code class="docutils literal notranslate"><span class="pre">remote_workstation_example.py</span></code></p>
<p><em>qubits</em>: 18<br />
<em>noise</em>: false</p>
<p>An example of a random circuit, offloaded to the dual-GPU QB Lambda server in Canberra.</p>
<p><code class="docutils literal notranslate"><span class="pre">set_circuit.py</span></code></p>
<p><em>qubits</em>: 3<br />
<em>gate depth</em>: 46<br />
<em>noise</em>: false</p>
<p>Example of performing an MCX operation on a target qubit initially in the <span class="math notranslate nohighlight">\(\ket{0}\)</span> state conditional on 2 control qubits in the <span class="math notranslate nohighlight">\(\ket{11}\)</span> state. The expected result is that the target qubit is flipped to the <span class="math notranslate nohighlight">\(\ket{1}\)</span> state.</p>
<p><code class="docutils literal notranslate"><span class="pre">subtraction.py</span></code></p>
<p><em>qubits</em>: 10<br />
<em>gate depth</em>: 13834<br />
<em>noise</em>: false</p>
<p>Example demonstrating subtraction between two registers, each containing 5 qubits each. Subtraction of all possible values of the 5-qubit configuration is performed.</p>
<p><code class="docutils literal notranslate"><span class="pre">superposition_adder.py</span></code></p>
<p><em>qubits</em>: 33<br />
<em>noise</em>: false</p>
<p>Example using amplitude estimation to find the mean amplitude of a superposition state. Takes a really long time to complete execution.</p>
<p><code class="docutils literal notranslate"><span class="pre">topology.py</span></code></p>
<p>A simple example that prints out circuit topology and connectedness.</p>
<p><code class="docutils literal notranslate"><span class="pre">vqee_example_1.py</span></code></p>
<p><em>qubits</em>: 4
<em>gate depth</em>: 1 for H2_explicit and 7 for H1_HEA
<em>noise</em>: false</p>
<p>Demonstrates the access and run of predefined examples in Qristal’s built-in VQE routines.</p>
<p><code class="docutils literal notranslate"><span class="pre">vqee_example_2.py</span></code></p>
<p><em>qubits</em>: 4
<em>gate depth</em>: 8
<em>noise</em>: false</p>
<p>Demonstrates manual problem setup and use and performance of different backends for Qristal’s built-in VQE routines. This example may take some time to run.</p>
<p><code class="docutils literal notranslate"><span class="pre">vqee_example_3.py</span></code></p>
<p><em>qubits</em>: 4
<em>gate depth</em>: 83
<em>noise</em>: false</p>
<p>Demonstrates how to inject python code into our c++ libs. Shows inclusion of external python chemistry package pyscf into Qristal’s built-in VQE routines.</p>
<p><code class="docutils literal notranslate"><span class="pre">vqee_example_4.py</span></code></p>
<p><em>qubits</em>: 4
<em>gate depth</em>: 1
<em>noise</em>: false</p>
<p>Demonstrates selection of a different classical optimization algorithm (Nelder-Mead), along with extra options to constrain the parameters and terminate the optimization.</p>
<p><code class="docutils literal notranslate"><span class="pre">simple_placement.py</span></code></p>
<p>A simple example demonstrating circuit placement based on backend topology.</p>
<p><code class="docutils literal notranslate"><span class="pre">noise_aware_placement.py</span></code></p>
<p>A simple example demonstrating noise-aware circuit placement by setting up a toy hardware configuration.</p>
<p><code class="docutils literal notranslate"><span class="pre">noise_aware_placement_noise_model.py</span></code></p>
<p>A simple example demonstrating noise-aware circuit placement by setting up a toy noise model.</p>
<p><code class="docutils literal notranslate"><span class="pre">noise_aware_placement_aws_rigetti.py</span></code></p>
<p>An example demonstrating integrated noise-aware placement during circuit execution on a hardware backend (e.g., Rigetti devices on AWS).
Valid AWS credentials are required to run the example.</p>
</section>
<section id="c">
<h2>C++<a class="headerlink" href="#c" title="Permalink to this headline"></a></h2>
<p><code class="docutils literal notranslate"><span class="pre">demo1</span></code></p>
<p><em>qubits</em>: 2<br />
<em>gate depth</em>: 3<br />
<em>noise</em>: false</p>
<p>A C++ implementation of <code class="docutils literal notranslate"><span class="pre">demo1.py</span></code>.</p>
<p><code class="docutils literal notranslate"><span class="pre">h1qb</span></code></p>
<p><em>qubits</em>: 2<br />
<em>gate depth</em>: 2<br />
<em>noise</em>: false</p>
<p>This example allows you to quickly switch circuit execution between a hardware QPU and a simulator.  See cpp/h1qb/README.md for more information.</p>
<p><code class="docutils literal notranslate"><span class="pre">qaoa</span></code></p>
<p><em>qubits</em>: 3
<em>qaoa_steps</em>: 2
<em>noise</em>: false</p>
<p>Demonstrates the use of Qristal’s built-in implementation of the QAOA simple algorithm. This example may take some time to run.</p>
<p><code class="docutils literal notranslate"><span class="pre">qbsdkcli</span></code></p>
<p>A command-line interface to Qristal.  A simple invocation after compiling the CLI is:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="p">.</span><span class="o">/</span><span class="n">qbsdkcli</span><span class="w"> </span><span class="o">-</span><span class="n">q2</span><span class="w"> </span><span class="o">--</span><span class="n">random</span><span class="o">=</span><span class="mi">2</span>
</pre></div>
</div>
<p>which will run a random circuit on 2 qubits, with gate depth of 2. Further details can be found <a href="cli.html">here</a>.</p>
<p><code class="docutils literal notranslate"><span class="pre">noise_model</span></code></p>
<p><em>qubits</em>: 2
<em>gate depth</em>: 6
<em>noise</em>: true</p>
<p>A C++ implementation of <code class="docutils literal notranslate"><span class="pre">noise_model.py</span></code>.</p>
<p><code class="docutils literal notranslate"><span class="pre">noise_model_user_defined</span></code></p>
<p><em>qubits</em>: 2
<em>gate depth</em>: 6
<em>noise</em>: true</p>
<p>A C++ implementation of <code class="docutils literal notranslate"><span class="pre">noise_model_user_defined.py</span></code>.</p>
<p><code class="docutils literal notranslate"><span class="pre">vqee</span></code></p>
<p><em>qubits</em>: 4<br />
<em>gate depth</em>: 83<br />
<em>noise</em>: false</p>
<p>Demonstrates the use of Qristal’s built-in VQE routines. Can be built with MPI support and parallelization over Pauli terms.</p>
<p><code class="docutils literal notranslate"><span class="pre">vqeeCalculator</span></code></p>
<p><code class="docutils literal notranslate"><span class="pre">vqeeCalculator</span></code> is a C++ compiled executable that enables command-line access to the functionality in <code class="docutils literal notranslate"><span class="pre">vqee</span></code>.</p>
<div class="toctree-wrapper compound">
<ul>
<li class="toctree-l1"><a class="reference internal" href="vqeeCalculator.html">In depth: <code class="docutils literal notranslate"><span class="pre">vqeeCalculator</span></code></a><ul>
<li class="toctree-l2"><a class="reference internal" href="vqeeCalculator.html#compiling">Compiling</a></li>
<li class="toctree-l2"><a class="reference internal" href="vqeeCalculator.html#limitations">Limitations</a></li>
<li class="toctree-l2"><a class="reference internal" href="vqeeCalculator.html#json-input-and-output">JSON input and output</a></li>
</ul>
</li>
</ul>
</div>
<p><code class="docutils literal notranslate"><span class="pre">noise_aware_placement_simple</span></code></p>
<p>A simple example demonstrates noise-aware circuit placement by setting up a toy hardware configuration.</p>
<p>A C++ implementation of <code class="docutils literal notranslate"><span class="pre">noise_aware_placement.py</span></code>.</p>
<p><code class="docutils literal notranslate"><span class="pre">noise_aware_placement_aws</span></code></p>
<p>An example demonstrates integrated noise-aware placement during circuit execution on hardware backend (e.g., Rigetti devices on AWS).
Valid AWS credentials are required to run the example.</p>
<p>A C++ implementation of <code class="docutils literal notranslate"><span class="pre">noise_aware_placement_aws_rigetti.py</span></code>.</p>
<p><code class="docutils literal notranslate"><span class="pre">circuit_optimization/circuit_optimizer.py</span></code></p>
<p>An example demonstrating the pattern-based circuit optimization pass.</p>
<p><code class="docutils literal notranslate"><span class="pre">circuit_optimization/remove_redundant_gates.py</span></code></p>
<p>An example demonstrating the redundant gate removal circuit optimization pass.</p>
<p><code class="docutils literal notranslate"><span class="pre">circuit_optimization/two_qubit_squash.py</span></code></p>
<p>An example demonstrating the two-qubit gate synthesis (squash) circuit optimization pass.</p>
<p><code class="docutils literal notranslate"><span class="pre">circuit_optimization/simplify_initial_conditions.py</span></code></p>
<p>An example demonstrating the contextual circuit optimization pass, which optimizes the circuit based on the knowledge of its initial state.</p>
<p><code class="docutils literal notranslate"><span class="pre">circuit_optimization/session_integration.py</span></code></p>
<p>An example demonstrating setting up a pipeline of circuit optimization passes when using Qristal.</p>
<p><code class="docutils literal notranslate"><span class="pre">cudaq_qft.py</span></code></p>
<p>Running QFT circuit constructed by the Qristal circuit builder on a CUDA Quantum simulator backend. Required CUDA Quantum support.</p>
</section>
<section id="c-with-cuda-quantum">
<h2>C++ with CUDA Quantum<a class="headerlink" href="#c-with-cuda-quantum" title="Permalink to this headline"></a></h2>
<p>A number of additional examples are only installed when Qristal is built with CUDA Quantum support.  None of these examples has noise enabled.</p>
<p><code class="docutils literal notranslate"><span class="pre">cudaq_qft</span></code></p>
<p>Running QFT circuit constructed by the Qristal circuit builder on a CUDA Quantum simulator backend.</p>
<p><code class="docutils literal notranslate"><span class="pre">benchmark1_cudaq</span></code></p>
<p>A 20 qubit GHZ state designed for benchmarking performance of CUDA Quantum and QASM. This is the CUDAQ version.</p>
<p><code class="docutils literal notranslate"><span class="pre">benchmark1_qasm</span></code></p>
<p>A 20 qubit GHZ state designed for benchmarking performance of CUDA Quantum and QASM. This is the QASM version.</p>
<p><code class="docutils literal notranslate"><span class="pre">cudaq_vqe_cobyla</span></code></p>
<p>Determination of the deuteron’s ground state energy using VQE with the Cobyla optimiser.</p>
<p><code class="docutils literal notranslate"><span class="pre">cudaq_vqe_hydrogens</span></code></p>
<p>Determination of the ground state of a chain of four hydrogen atoms, using VQE with the L-BFGS optimiser.</p>
<p><code class="docutils literal notranslate"><span class="pre">cudaq_vqe_lbfgs</span></code></p>
<p>Determination of the deuteron’s ground state energy using VQE with the L-BFGS optimiser.</p>
</section>
<section id="works-in-progress">
<h2>Works in progress<a class="headerlink" href="#works-in-progress" title="Permalink to this headline"></a></h2>
<p>Examples in the <code class="docutils literal notranslate"><span class="pre">wip</span></code> folder are works in progress.  These either do not presently run or still need additional testing.  This is a known issue, and thus not worth reporting as a new bug.</p>
<p><code class="docutils literal notranslate"><span class="pre">aws_braket</span></code></p>
<p>These need work on the aws_s3 argument.  You should be able to get the first two to run by just setting <code class="docutils literal notranslate"><span class="pre">s.aws_s3</span></code> to the name of an s3 bucket that you personally have access to (you need to have run <code class="docutils literal notranslate"><span class="pre">aws</span> <span class="pre">configure</span></code>, set up the bucket, etc).</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">aws_noise_demo.py</span></code><br />
An example of circuit offload to AWS Braket, and an explicit test of the decay of coherence over time, as implemented in the default noise model.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">qft.py</span></code><br />
A Fourier transform performed on an AWS simulator.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">verbatim.py</span></code><br />
A circuit run on Rigetti hardware using the AWS <code class="docutils literal notranslate"><span class="pre">verbatim</span></code> option.</p></li>
</ul>
<p><code class="docutils literal notranslate"><span class="pre">lambda_accelerator</span></code></p>
<p>Further examples using a remote accelerator.</p>
<p><code class="docutils literal notranslate"><span class="pre">qap</span></code></p>
<p>Some additional QAOA examples using recursive QAOA routines.</p>
<p><code class="docutils literal notranslate"><span class="pre">vqe</span></code></p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">h2_vqe_aswap.py</span></code><br />
Example using the variational quantum eigensolver and ASWAP ansatz to obtain the ground state energy of a H2 molecule.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">h2_vqe_uccsd.py</span></code><br />
Example using the variational quantum eigensolver and UCCSD ansatz to obtain the ground state energy of a H2 molecule.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">h4_vqe_uccsd.py</span></code><br />
Example using the variational quantum eigensolver and UCCSD ansatz to obtain the ground state energy of H4.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">h4_vqe_uccsd_aer</span></code><br />
Example using the variational quantum eigensolver, a UCCSD ansatz and the AER simulator to obtain the ground state energy of H4.</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">h6_vqe_uccsd_aer</span></code><br />
Example using the variational quantum eigensolver, a UCCSD ansatz and the AER simulator to obtain the ground state energy of H6.</p></li>
</ul>
</section>
</section>


           </div>
          </div>
          <footer>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2023, Quantum Brilliance Pty Ltd.</p>
  </div>

   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>