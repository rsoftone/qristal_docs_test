<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Quantum Computing &mdash; Quantum SDK  documentation</title>
      <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../_static/collapsible-lists/css/tree_view.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script async="async" src="https://www.googletagmanager.com/gtag/js?id=G-EML76VL6ZZ"></script>
        <script src="../_static/js/qb_ga.js"></script>
        <script src="../_static/collapsible-lists/js/CollapsibleLists.compressed.js"></script>
        <script src="../_static/collapsible-lists/js/apply-collapsible-lists.js"></script>
        <script>window.MathJax = {"options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
        <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="Noise models" href="noise_models.html" />
    <link rel="prev" title="Command-line interface" href="cli.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../index.html" class="icon icon-home">
            Quantum SDK
              <img src="../_static/qb_logo.png" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Basic Usage</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="getting_started.html">Getting started</a></li>
<li class="toctree-l1"><a class="reference internal" href="examples.html">Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="cli.html">Command-line interface</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Quantum Computing</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#quantum-gates">Quantum Gates</a></li>
</ul>
</li>
<li class="toctree-l1"><a class="reference internal" href="noise_models.html">Noise models</a></li>
<li class="toctree-l1"><a class="reference internal" href="noise_models.html#user-defined-noise-models">User defined noise models</a></li>
<li class="toctree-l1"><a class="reference internal" href="vqe.html">Variational Quantum Eigensolver (VQE)</a></li>
<li class="toctree-l1"><a class="reference internal" href="qml.html">Quantum Machine Learning (QML)</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Source Code Documentation</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../_cpp_api/library_root.html">C++ API</a></li>
<li class="toctree-l1"><a class="reference internal" href="python_autodoc.html">Python API</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Quantum SDK</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">Quantum Computing</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/rst/quantum_computing.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="quantum-computing">
<h1>Quantum Computing<a class="headerlink" href="#quantum-computing" title="Permalink to this headline"></a></h1>
<section class="tex2jax_ignore mathjax_ignore" id="quantum-gates">
<h2>Quantum Gates<a class="headerlink" href="#quantum-gates" title="Permalink to this headline"></a></h2>
<p>This section is a quick reference on quantum gates expressed in these formats:</p>
<ul>
<li><p>I - Identity</p>
<ul>
<li><p>Unitary Description and Decomposition Rules</p>
<p>This operator leaves a qubit unchanged, so that</p>
<p><span class="math notranslate nohighlight">\(|0\rangle \rightarrow |0\rangle\)</span> and <span class="math notranslate nohighlight">\(|1\rangle \rightarrow |1\rangle\)</span>.</p>
<p>It is expressed by the matrix  <span class="math notranslate nohighlight">\(I = \left(\begin{array}{cc} 1 &amp; 0 \\ 0 &amp; 1\end{array} \right)\)</span>, but implemented by the absence of any operator.</p>
</li>
</ul>
</li>
<li><p>H - Hadamard</p>
<ul>
<li><p>Unitary Description and Decomposition Rules</p>
<p>This operator mixes the measurement basis states, so that</p>
<p><span class="math notranslate nohighlight">\(|0\rangle \rightarrow \frac{1}{\sqrt{2}}\Big(|0\rangle + |1\rangle\Big)\)</span> and <span class="math notranslate nohighlight">\(|1\rangle \rightarrow \frac{1}{\sqrt{2}}\Big(|0\rangle - |1\rangle\Big)\)</span>.</p>
<p>It is given by the matrix  <span class="math notranslate nohighlight">\(H = \frac{1}{\sqrt{2}} \left(\begin{array}{rr} 1 &amp; 1 \\ 1 &amp; -1 \end{array} \right)\)</span>.</p>
</li>
<li><p>OpenQASM</p>
<p>Gate format: <code class="docutils literal notranslate"><span class="pre">h</span> <span class="pre">&lt;target_qubit&gt;;</span></code></p>
</li>
<li><p>XASM</p>
<p>Gate format: <code class="docutils literal notranslate"><span class="pre">H(&lt;target_qubit&gt;);</span></code></p>
</li>
<li><p>QB Native Transpilation</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">h</span><span class="p">(</span><span class="n">q0</span><span class="p">)</span>
</pre></div>
</div>
<p>where q0 is the qubit.</p>
</li>
</ul>
</li>
<li><p>X - Pauli rotation around the x-axis by pi</p>
<ul>
<li><p>Unitary Description and Decomposition Rules</p>
<p>This operator performs an X, or NOT operation on a qubit, turning</p>
<p><span class="math notranslate nohighlight">\(|0\rangle \rightarrow |1\rangle\)</span> and <span class="math notranslate nohighlight">\(|1\rangle \rightarrow |0\rangle\)</span>.</p>
<p>It is given by the matrix  <span class="math notranslate nohighlight">\(X = \left(\begin{array}{cc} 0 &amp; 1 \\ 1 &amp; 0\end{array} \right)\)</span>.</p>
</li>
<li><p>OpenQASM</p>
<p>Gate format: <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">&lt;target_qubit&gt;;</span></code></p>
</li>
<li><p>XASM</p>
<p>Gate format: X<code class="docutils literal notranslate"><span class="pre">(&lt;target_qubit&gt;);</span></code></p>
</li>
<li><p>QB Native Transpilation</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">x</span><span class="p">(</span><span class="n">q0</span><span class="p">)</span>
</pre></div>
</div>
<p>where q0 is the qubit.</p>
</li>
</ul>
</li>
<li><p>Y - Pauli rotation around the y-axis by pi</p>
<ul>
<li><p>Unitary Description and Decomposition Rules</p>
<p>This operator performs a Y operation on a qubit, turning</p>
<p><span class="math notranslate nohighlight">\(|0\rangle \rightarrow -i|1\rangle\)</span> and <span class="math notranslate nohighlight">\(|1\rangle \rightarrow i\|0\rangle\)</span>.</p>
<p>It is given by the matrix  <span class="math notranslate nohighlight">\(Y = \left(\begin{array}{cc} 0 &amp; -i \\ i &amp; 0\end{array} \right)\)</span></p>
</li>
<li><p>OpenQASM</p>
<p>Gate format: <code class="docutils literal notranslate"><span class="pre">y</span> <span class="pre">&lt;target_qubit&gt;;</span></code></p>
</li>
<li><p>XASM</p>
<p>Gate format: Y<code class="docutils literal notranslate"><span class="pre">(&lt;target_qubit&gt;);</span></code></p>
</li>
<li><p>QB Native Transpilation</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">y</span><span class="p">(</span><span class="n">q0</span><span class="p">)</span>
</pre></div>
</div>
<p>where q0 is the qubit.</p>
</li>
</ul>
</li>
<li><p>Z - Pauli rotation around the z-axis by pi</p>
<ul>
<li><p>Unitary Description and Decomposition Rules</p>
<p>This operator performs a Z operation on a qubit, turning</p>
<p><span class="math notranslate nohighlight">\(|0\rangle \rightarrow |0\rangle\)</span> and <span class="math notranslate nohighlight">\(|1\rangle \rightarrow |1\rangle\)</span>.</p>
<p>It is given by the matrix  <span class="math notranslate nohighlight">\(Z = \left(\begin{array}{cc} 1 &amp; 0 \\ 0 &amp; -1 \end{array} \right)\)</span></p>
</li>
<li><p>OpenQASM</p>
<p>Gate format: <code class="docutils literal notranslate"><span class="pre">z</span> <span class="pre">&lt;target_qubit&gt;;</span></code></p>
</li>
<li><p>XASM</p>
<p>Gate format: <code class="docutils literal notranslate"><span class="pre">Z(&lt;target_qubit&gt;);</span></code></p>
</li>
<li><p>QB Native Transpilation</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">z</span><span class="p">(</span><span class="n">q0</span><span class="p">)</span>
</pre></div>
</div>
<p>where q0 is the qubit.</p>
</li>
</ul>
</li>
<li><p>CNOT - controlled-X</p>
<ul>
<li><p>Unitary Description and Decomposition Rules</p>
<p>For a given control qubit <span class="math notranslate nohighlight">\(q_0\)</span> and target qubit <span class="math notranslate nohighlight">\(q_1\)</span> this operator performs a X operation on the <span class="math notranslate nohighlight">\(q_1\)</span> if <span class="math notranslate nohighlight">\(q_0\)</span> equals one, but leaves <span class="math notranslate nohighlight">\(q_1\)</span> unchanged, <em>i.e.</em> the identity operation, if <span class="math notranslate nohighlight">\(q_0\)</span> equals zero. It is given by the matrix</p>
<p><span class="math notranslate nohighlight">\(CX_{2q_0 + q_1 + 1,2q_0 + q_1 + 1} = \text{diag}(I,X) = \left(\begin{array}{cccc}1 &amp; 0 &amp; 0 &amp; 0 \\ 0 &amp; 1 &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; 0 &amp; 1 \\ 0 &amp; 0 &amp; 1 &amp; 0\end{array} \right)\)</span></p>
</li>
<li><p>OpenQASM</p>
<p>Gate format: <code class="docutils literal notranslate"><span class="pre">cx</span> <span class="pre">&lt;control_qubit&gt;</span> <span class="pre">,</span> <span class="pre">&lt;target_qubit&gt;;</span></code></p>
<p>where q[0] is the control qubit and q[1] is the target qubit.</p>
</li>
<li><p>XASM</p>
<p>Gate format: <code class="docutils literal notranslate"><span class="pre">CX(&lt;control_qubit&gt;,&lt;target_qubit&gt;);</span></code></p>
</li>
<li><p>QB Native Transpilation</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">cx</span><span class="p">(</span><span class="n">q0</span><span class="p">,</span> <span class="n">q1</span><span class="p">)</span>
</pre></div>
</div>
<p>where q0 is the control qubit and q1 is the target qubit.</p>
</li>
</ul>
</li>
<li><p>CY - controlled-Y</p>
<ul>
<li><p>Unitary Description and Decomposition Rules</p>
<p>For a given control qubit <span class="math notranslate nohighlight">\(q_0\)</span> and target qubit <span class="math notranslate nohighlight">\(q_1\)</span> this operator performs a Y operation on the <span class="math notranslate nohighlight">\(q_1\)</span> if <span class="math notranslate nohighlight">\(q_0\)</span> equals one, but leaves <span class="math notranslate nohighlight">\(q_1\)</span> unchanged, <em>i.e.</em> the identity operation, if <span class="math notranslate nohighlight">\(q_0\)</span> equals zero. It is given by the matrix</p>
<p><span class="math notranslate nohighlight">\(CY_{2q_0 + q_1 + 1,2q_0 + q_1 + 1} = \text{diag}(I,Y) = \left(\begin{array}{cccc}1 &amp; 0 &amp; 0 &amp; 0 \\ 0 &amp; 1 &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; 0 &amp; -i \\ 0 &amp; 0 &amp; i &amp; 0\end{array} \right)\)</span></p>
<p>where <span class="math notranslate nohighlight">\(i^2 = -1\)</span>.</p>
</li>
<li><p>OpenQASM</p>
<p>Gate format: <code class="docutils literal notranslate"><span class="pre">cy</span> <span class="pre">&lt;control_qubit&gt;</span> <span class="pre">,</span> <span class="pre">&lt;target_qubit&gt;;</span></code></p>
</li>
<li><p>XASM</p>
<p>Gate format: <code class="docutils literal notranslate"><span class="pre">CY(&lt;control_qubit&gt;,&lt;target_qubit&gt;);</span></code></p>
</li>
<li><p>QB Native Transpilation</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">cy</span><span class="p">(</span><span class="n">q0</span><span class="p">,</span> <span class="n">q1</span><span class="p">)</span>
</pre></div>
</div>
<p>where q0 is the control qubit and q1 is the target qubit.</p>
</li>
</ul>
</li>
<li><p>CZ - controlled-Z</p>
<ul>
<li><p>Unitary Description and Decomposition Rules</p>
<p>For a given control qubit <span class="math notranslate nohighlight">\(q_0\)</span> and target qubit <span class="math notranslate nohighlight">\(q_1\)</span> this operator performs a Z operation on the <span class="math notranslate nohighlight">\(q_1\)</span> if <span class="math notranslate nohighlight">\(q_0\)</span> equals one, but leaves <span class="math notranslate nohighlight">\(q_1\)</span> unchanged, <em>i.e.</em> the identity operation, if <span class="math notranslate nohighlight">\(q_0\)</span> equals zero. It is given by the matrix</p>
<p><span class="math notranslate nohighlight">\(CZ_{2q_0 + q_1 + 1,2q_0 + q_1 + 1} = \text{diag}(I,Z) = \left(\begin{array}{cccc}1 &amp; 0 &amp; 0 &amp; 0 \\ 0 &amp; 1 &amp; 0 &amp; 0 \\ 0 &amp; 0 &amp; 1 &amp; 0 \\ 0 &amp; 0 &amp; 0 &amp; -1\end{array} \right)\)</span></p>
</li>
<li><p>OpenQASM</p>
<p>Gate format: <code class="docutils literal notranslate"><span class="pre">cz</span> <span class="pre">&lt;control_qubit&gt;</span> <span class="pre">,</span> <span class="pre">&lt;target_qubit&gt;;</span></code></p>
</li>
<li><p>XASM</p>
<p>Gate format: <code class="docutils literal notranslate"><span class="pre">CZ(&lt;control_qubit&gt;,&lt;target_qubit&gt;);</span></code></p>
</li>
<li><p>QB Native Transpilation</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">cz</span><span class="p">(</span><span class="n">q0</span><span class="p">,</span> <span class="n">q1</span><span class="p">)</span>
</pre></div>
</div>
<p>where q0 is the control qubit and q1 is the target qubit.</p>
</li>
</ul>
</li>
<li><p><span class="math notranslate nohighlight">\(R_x(\theta)\)</span> - Pauli rotation on <em>X</em>-axis by <span class="math notranslate nohighlight">\(\theta\)</span></p>
<ul>
<li><p>Unitary Description and Decomposition Rules</p>
<p>This operator rotates a qubit around the <em>X</em>-axis of the Bloch sphere by an angle of <span class="math notranslate nohighlight">\(\theta\)</span>. It partially interchanges <span class="math notranslate nohighlight">\(|0\rangle\)</span> with <span class="math notranslate nohighlight">\(|1\rangle\)</span> and introduces a relative phase between the two components, so</p>
<p><span class="math notranslate nohighlight">\(|0\rangle \rightarrow \cos\left(\frac{\theta}{2}\right)|0\rangle -i \sin\left(\frac{\theta}{2}\right) |1\rangle\)</span>   and    <span class="math notranslate nohighlight">\(|1\rangle \rightarrow -i\sin(\frac{\theta}{2})|0\rangle + \cos(\frac{\theta}{2})|1\rangle\)</span>.</p>
<p>It is given by the matrix</p>
<p><span class="math notranslate nohighlight">\(X(\theta) = I \cos\!\left(\frac{\theta}{2}\right) -i \sigma_X  \sin\!\left(\frac{\theta}{2}\right) = \left(\begin{array}{cc} \cos\left(\frac{\theta}{2}\right) &amp; -i\sin\left(\frac{\theta}{2}\right) \\ &amp; \\-i\sin\left(\frac{\theta}{2}\right) &amp; \cos\left(\frac{\theta}{2}\right)\end{array} \right)\)</span>,</p>
<p>where <span class="math notranslate nohighlight">\(I\)</span> is the identity matrix and <span class="math notranslate nohighlight">\(\sigma_X\)</span> is the Pauli matrix</p>
<p><span class="math notranslate nohighlight">\(\sigma_X = \left(\begin{array}{cc} 0 &amp; 1 \\ 1 &amp; 0 \end{array}\right)\)</span>.</p>
</li>
<li><p>OpenQASM</p>
<p>Gate format: <code class="docutils literal notranslate"><span class="pre">rx(&lt;theta&gt;)</span> <span class="pre">&lt;target_qubit&gt;;</span></code></p>
<p>where  <code class="docutils literal notranslate"><span class="pre">&lt;theta&gt;</span></code> is the angle of rotation about the X-axis.</p>
</li>
<li><p>XASM</p>
<p>Gate format: <code class="docutils literal notranslate"><span class="pre">RX(&lt;target_qubit&gt;,</span> <span class="pre">&lt;theta&gt;);</span></code></p>
</li>
<li><p>QB Native Transpilation</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">rx</span><span class="p">(</span><span class="n">q0</span><span class="p">,</span><span class="n">_theta</span><span class="p">)</span>
</pre></div>
</div>
<p>where q0 is the qubit and _<em>theta</em> is the angle of rotation about the X-axis.</p>
</li>
</ul>
</li>
<li><p><span class="math notranslate nohighlight">\(R_y(\phi)\)</span> - Pauli rotation on <em>Y</em>-axis by <span class="math notranslate nohighlight">\(\phi\)</span></p>
<ul>
<li><p>Unitary Description and Decomposition Rules</p>
<p>This operator rotates a qubit around the <em>Y</em>-axis of the Bloch sphere by an angle of <span class="math notranslate nohighlight">\(\phi\)</span>, partially interchanging <span class="math notranslate nohighlight">\(|0\rangle\)</span> with <span class="math notranslate nohighlight">\(|1\rangle\)</span>, so</p>
<p><span class="math notranslate nohighlight">\(|0\rangle \rightarrow \cos\left(\frac{\phi}{2}\right)|0\rangle - \sin\left(\frac{\phi}{2}\right) |1\rangle\)</span>   and    <span class="math notranslate nohighlight">\(|1\rangle \rightarrow \sin(\frac{\phi}{2})|0\rangle + \cos(\frac{\phi}{2})|1\rangle\)</span>.</p>
<p>It is given by the matrix</p>
<p><span class="math notranslate nohighlight">\(Y(\phi) = I \cos\!\left(\frac{\phi}{2}\right) -i \sigma_Y  \sin\!\left(\frac{\phi}{2}\right) = \left(\begin{array}{cc} \cos\left(\frac{\phi}{2}\right) &amp; -\sin\left(\frac{\phi}{2}\right) \\ &amp; \\ \sin\left(\frac{\phi}{2}\right) &amp; \cos\left(\frac{\phi}{2}\right)\end{array} \right)\)</span>,</p>
<p>where <span class="math notranslate nohighlight">\(I\)</span> is the identity matrix and <span class="math notranslate nohighlight">\(\sigma_Y\)</span> is the Pauli matrix</p>
<p><span class="math notranslate nohighlight">\(\sigma_Y = \left(\begin{array}{cc} 0 &amp; -i \\ i &amp; 0 \end{array}\right)\)</span>.</p>
</li>
<li><p>OpenQASM</p>
<p>Gate format: <code class="docutils literal notranslate"><span class="pre">ry(&lt;phi&gt;)</span> <span class="pre">&lt;target_qubit&gt;;</span></code></p>
<p>where  <code class="docutils literal notranslate"><span class="pre">&lt;phi&gt;</span></code> is the angle of rotation about the Y-axis.</p>
</li>
<li><p>XASM</p>
<p>Gate format: <code class="docutils literal notranslate"><span class="pre">RY(&lt;target_qubit&gt;,</span> <span class="pre">&lt;phi&gt;);</span></code></p>
</li>
<li><p>QB Native Transpilation</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">ry</span><span class="p">(</span><span class="n">q0</span><span class="p">,</span><span class="n">_phi</span><span class="p">)</span>
</pre></div>
</div>
<p>where q0 is the qubit and <em>_phi</em> is the angle of rotation about the Z-axis.</p>
</li>
</ul>
</li>
<li><p><span class="math notranslate nohighlight">\(R_z(\lambda)\)</span> - Pauli rotation on <em>Z</em>-axis by <span class="math notranslate nohighlight">\(\lambda\)</span></p>
<ul>
<li><p>Unitary Description and Decomposition Rules</p>
<p>This operator rotates a qubit around the <em>Z</em>-axis of the Bloch sphere by an angle of <span class="math notranslate nohighlight">\(\lambda\)</span>. It introduces a relative phase between the two components, so</p>
<p><span class="math notranslate nohighlight">\(|0\rangle \rightarrow -i\sin(\frac{\lambda}{2})|0\rangle\)</span>   and    <span class="math notranslate nohighlight">\(|1\rangle \rightarrow i\sin(\frac{\lambda}{2})|1\rangle\)</span>.</p>
<p>It is given by the matrix</p>
<p><span class="math notranslate nohighlight">\(Z(\lambda) = I \cos\!\left(\frac{\lambda}{2}\right) -i \sigma_Z  \sin\!\left(\frac{\lambda}{2}\right) = \left(\begin{array}{cc} \cos\left(\frac{\lambda}{2}\right) -i\sin\left(\frac{\lambda}{2}\right) &amp; 0 \\ &amp; \\0 &amp; \cos\left(\frac{\lambda}{2}\right) +  i\sin\left(\frac{\lambda}{2}\right) \end{array} \right)\)</span>,</p>
<p>where <span class="math notranslate nohighlight">\(I\)</span> is the identity matrix and <span class="math notranslate nohighlight">\(\sigma_Z\)</span> is the Pauli matrix</p>
<p><span class="math notranslate nohighlight">\(\sigma_Z = \left(\begin{array}{cc} 1 &amp; 0 \\ 0 &amp; -1\end{array}\right)\)</span>.</p>
</li>
<li><p>OpenQASM</p>
<p>Gate format: <code class="docutils literal notranslate"><span class="pre">rz(&lt;lambda&gt;)</span> <span class="pre">&lt;target_qubit&gt;;</span></code></p>
<p>where  <code class="docutils literal notranslate"><span class="pre">&lt;lambda&gt;</span></code> is the angle of rotation about the Z-axis.</p>
</li>
<li><p>XASM</p>
<p>Gate format: <code class="docutils literal notranslate"><span class="pre">RZ(&lt;target_qubit&gt;,</span> <span class="pre">&lt;lambda&gt;);</span></code></p>
</li>
<li><p>QB Native Transpilation</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">rz</span><span class="p">(</span><span class="n">q0</span><span class="p">,</span><span class="n">_lambda</span><span class="p">)</span>
</pre></div>
</div>
<p>where q0 is the qubit and <em>_lambda</em> is the angle of rotation about the Z-axis.</p>
</li>
</ul>
</li>
<li><p>S - rotation on z-axis by 0.5*pi</p>
<ul>
<li><p>Unitary Description and Decomposition Rules</p>
<p>This operator rotates a qubit around the <em>Z</em>-axis of the Bloch sphere by an angle of <span class="math notranslate nohighlight">\(\frac{\pi}{2}\)</span>. It introduces a relative phase between the two components, where</p>
<p><span class="math notranslate nohighlight">\(|0\rangle \rightarrow -i\sin(\frac{\pi}{4})|0\rangle\)</span>   and    <span class="math notranslate nohighlight">\(|1\rangle \rightarrow i\sin(\frac{\pi}{4})|1\rangle\)</span>.</p>
<p>It is given by the matrix</p>
<p><span class="math notranslate nohighlight">\(S = Z\left(\frac{\pi}{2}\right) = I \cos\!\left(\frac{\pi}{4}\right) -i \sigma_Z  \sin\!\left(\frac{\pi}{4}\right) = \left(\begin{array}{cc} \cos\left(\frac{\pi}{4}\right) -i\sin\left(\frac{\pi}{4}\right) &amp; 0 \\ &amp; \\0 &amp; \cos\left(\frac{\pi}{4}\right) +  i\sin\left(\frac{\pi}{4}\right) \end{array} \right)\)</span>,</p>
<p>where <span class="math notranslate nohighlight">\(I\)</span> is the identity matrix and <span class="math notranslate nohighlight">\(\sigma_Z\)</span> is the Pauli matrix</p>
<p><span class="math notranslate nohighlight">\(\sigma_Z = \left(\begin{array}{cc} 1 &amp; 0 \\ 0 &amp; -1\end{array}\right)\)</span>.</p>
</li>
<li><p>OpenQASM</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">math</span>
<span class="n">rz</span><span class="p">(</span><span class="mf">0.5</span><span class="o">*</span><span class="n">math</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span> <span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
</pre></div>
</div>
<p>where q[0] is the qubit.</p>
</li>
<li><p>XASM</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">math</span>
<span class="n">Rz</span><span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="mf">0.5</span><span class="o">*</span><span class="n">math</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>
</pre></div>
</div>
<p>where q[0] is the qubit.</p>
</li>
<li><p>QB Native Transpilation</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">math</span>
<span class="n">rz</span><span class="p">(</span><span class="n">q0</span><span class="p">,</span><span class="mf">0.5</span><span class="o">*</span><span class="n">math</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>
</pre></div>
</div>
<p>where q0 is the qubit.</p>
</li>
</ul>
</li>
<li><p>T - rotation on z-axis by 0.25*pi</p>
<ul>
<li><p>Unitary Description and Decomposition Rules</p>
<p>This operator rotates a qubit around the <em>Z</em>-axis of the Bloch sphere by an angle of <span class="math notranslate nohighlight">\(\frac{\pi}{4}\)</span>. It introduces a relative phase between the two components, where</p>
<p><span class="math notranslate nohighlight">\(|0\rangle \rightarrow -i\sin(\frac{\pi}{8})|0\rangle\)</span>   and    <span class="math notranslate nohighlight">\(|1\rangle \rightarrow i\sin(\frac{\pi}{8})|1\rangle\)</span>.</p>
<p>It is given by the matrix</p>
<p><span class="math notranslate nohighlight">\(S = Z\left(\frac{\pi}{4}\right) = I \cos\!\left(\frac{\pi}{8}\right) -i \sigma_Z  \sin\!\left(\frac{\pi}{8}\right) = \left(\begin{array}{cc} \cos\left(\frac{\pi}{8}\right) -i\sin\left(\frac{\pi}{8}\right) &amp; 0 \\ &amp; \\0 &amp; \cos\left(\frac{\pi}{8}\right) +  i\sin\left(\frac{\pi}{8}\right) \end{array} \right)\)</span>,</p>
<p>where <span class="math notranslate nohighlight">\(I\)</span> is the identity matrix and <span class="math notranslate nohighlight">\(\sigma_Z\)</span> is the Pauli matrix</p>
<p><span class="math notranslate nohighlight">\(\sigma_Z = \left(\begin{array}{cc} 1 &amp; 0 \\ 0 &amp; -1\end{array}\right)\)</span>.</p>
</li>
<li><p>OpenQASM</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">math</span>
<span class="n">rz</span><span class="p">(</span><span class="mf">0.25</span><span class="o">*</span><span class="n">math</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span> <span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
</pre></div>
</div>
<p>where q[0] is the qubit.</p>
</li>
<li><p>XASM</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">math</span>
<span class="n">RZ</span><span class="p">(</span><span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="mf">0.25</span><span class="o">*</span><span class="n">math</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>
</pre></div>
</div>
<p>where q[0] is the qubit.</p>
</li>
<li><p>QB Native Transpilation</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">math</span>
<span class="n">rz</span><span class="p">(</span><span class="n">q0</span><span class="p">,</span><span class="mf">0.25</span><span class="o">*</span><span class="n">math</span><span class="o">.</span><span class="n">pi</span><span class="p">)</span>
</pre></div>
</div>
<p>where q0 is the qubit.</p>
</li>
</ul>
</li>
<li><p><span class="math notranslate nohighlight">\(U(\theta,\phi,\lambda)\)</span> - arbitrary rotation</p>
<ul>
<li><p>Unitary Description and Decomposition Rules</p>
<p>If used for an <strong>ansatz</strong> that will require <strong>automatic differentiation</strong> (AD), replace <span class="math notranslate nohighlight">\(U\)</span> with the decomposition:</p>
<p><span class="math notranslate nohighlight">\(U(\theta, \phi, \lambda) = R_y(-\frac{\pi}{2})*R_x(\phi)*R_y(\theta)*R_x(\lambda)*R_y(\frac{\pi}{2})\)</span></p>
<p><strong>Other useful expressions:</strong></p>
<p><span class="math notranslate nohighlight">\(R_x(\alpha) = U(\alpha, -\frac{\pi}{2}, \frac{\pi}{2})\)</span></p>
<p><span class="math notranslate nohighlight">\(R_y(\alpha) = U(\alpha, 0, 0)\)</span></p>
<p><span class="math notranslate nohighlight">\(R_z(\alpha) = U(0, \alpha, 0) = U(0, 0, \alpha)\)</span></p>
</li>
<li><p>OpenQASM</p>
<p>Gate format: <code class="docutils literal notranslate"><span class="pre">u(&lt;theta&gt;,</span> <span class="pre">&lt;phi&gt;,</span> <span class="pre">&lt;lambda&gt;)</span> <span class="pre">&lt;target_qubit&gt;;</span></code></p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="c1">// Format: u(theta, phi, lambda) target_qubit</span>

<span class="n">__qpu__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">QBCIRCUIT</span><span class="p">(</span><span class="n">qreg</span><span class="w"> </span><span class="n">q</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="n">OPENQASM</span><span class="w"> </span><span class="mf">2.0</span><span class="p">;</span>
<span class="n">include</span><span class="w"> </span><span class="s">&quot;qelib1.inc&quot;</span><span class="p">;</span>
<span class="n">creg</span><span class="w"> </span><span class="n">c</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>

<span class="c1">// theta = 0.2</span>
<span class="c1">// phi = -0.25</span>
<span class="c1">// lambda = 1.1</span>
<span class="n">u</span><span class="p">(</span><span class="mf">0.2</span><span class="p">,</span><span class="w"> </span><span class="mf">-0.25</span><span class="p">,</span><span class="w"> </span><span class="mf">1.1</span><span class="p">)</span><span class="w"> </span><span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>

<span class="n">measure</span><span class="w"> </span><span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="p">}</span>
</pre></div>
</div>
</li>
<li><p>XASM</p>
<p>Gate format: <code class="docutils literal notranslate"><span class="pre">U(&lt;target_qubit&gt;,</span> <span class="pre">&lt;theta&gt;,</span> <span class="pre">&lt;phi&gt;,</span> <span class="pre">&lt;lambda&gt;);</span></code></p>
</li>
<li><p>QB Native Transpilation</p>
<p>We use the decomposition:</p>
<p><span class="math notranslate nohighlight">\(U(\theta, \phi, \lambda) := R_y(-\frac{\pi}{2})*R_x(\phi)*R_y(\theta)*R_x(\lambda)*R_y(\frac{\pi}{2})\)</span></p>
</li>
</ul>
</li>
<li><p>Measurement</p>
<ul>
<li><p>Description</p>
<p>Measurement is inherently non-unitary. The physical operation selects one of the components of the given quantum registry at random, where the probability of any particular component being selected is given by the square of its amplitude. For this reason it is advisable to call multiple shots (Qristal’s default is 1024) so that the distribution of possible outcomes is apparent.</p>
</li>
<li><p>OpenQASM</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">measure</span> <span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">-&gt;</span> <span class="n">c</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
</pre></div>
</div>
<p>where q[0] is the qubit and c[0] is the corresponding classical bit to which it is measured.</p>
</li>
<li><p>XASM</p>
<p>Gate format: <code class="docutils literal notranslate"><span class="pre">Measure(&lt;target_qubit&gt;);</span></code></p>
</li>
<li><p>QB Native Transpilation</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">measure</span><span class="p">(</span><span class="n">q0</span><span class="p">,</span> <span class="n">c0</span><span class="p">)</span>
</pre></div>
</div>
<p>where q0 is the qubit and c0 is the corresponding classical bit to which it is measured.</p>
</li>
</ul>
</li>
</ul>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="cli.html" class="btn btn-neutral float-left" title="Command-line interface" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="noise_models.html" class="btn btn-neutral float-right" title="Noise models" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2023, Quantum Brilliance Pty Ltd.</p>
  </div>

   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>