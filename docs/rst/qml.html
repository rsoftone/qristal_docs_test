<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Quantum Machine Learning (QML) &mdash; Quantum SDK  documentation</title>
      <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../_static/collapsible-lists/css/tree_view.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script async="async" src="https://www.googletagmanager.com/gtag/js?id=G-215J15FW78"></script>
        <script src="../_static/js/qb_ga.js"></script>
        <script src="../_static/collapsible-lists/js/CollapsibleLists.compressed.js"></script>
        <script src="../_static/collapsible-lists/js/apply-collapsible-lists.js"></script>
        <script>window.MathJax = {"options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
        <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="next" title="C++ API" href="../_cpp_api/library_root.html" />
    <link rel="prev" title="Variational Quantum Eigensolver (VQE)" href="vqe.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../index.html" class="icon icon-home">
            Quantum SDK
              <img src="../_static/qb_logo.png" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Basic Usage</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="getting_started.html">Getting started</a></li>
<li class="toctree-l1"><a class="reference internal" href="examples.html">Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="cli.html">Command-line interface</a></li>
<li class="toctree-l1"><a class="reference internal" href="quantum_computing.html">Quantum Computing</a></li>
<li class="toctree-l1"><a class="reference internal" href="noise_models.html">Noise models</a></li>
<li class="toctree-l1"><a class="reference internal" href="noise_models.html#user-defined-noise-models">User defined noise models</a></li>
<li class="toctree-l1"><a class="reference internal" href="vqe.html">Variational Quantum Eigensolver (VQE)</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Quantum Machine Learning (QML)</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#defining-a-variational-quantum-circuit">Defining a variational quantum circuit</a></li>
<li class="toctree-l2"><a class="reference internal" href="#using-qmlexecutor-to-assign-values-to-parameters">Using QMLExecutor to assign values to parameters</a></li>
<li class="toctree-l2"><a class="reference internal" href="#converting-the-parametrized-quantum-circuit-to-a-neural-network-layer">Converting the parametrized quantum circuit to a neural network layer</a></li>
<li class="toctree-l2"><a class="reference internal" href="#references">References</a></li>
</ul>
</li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Source Code Documentation</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../_cpp_api/library_root.html">C++ API</a></li>
<li class="toctree-l1"><a class="reference internal" href="python_autodoc.html">Python API</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Quantum SDK</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">Quantum Machine Learning (QML)</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/rst/qml.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section class="tex2jax_ignore mathjax_ignore" id="quantum-machine-learning-qml">
<h1>Quantum Machine Learning (QML)<a class="headerlink" href="#quantum-machine-learning-qml" title="Permalink to this headline"></a></h1>
<p>This page covers the setup and execution of a Hybrid Quantum Machine Learning workflow in Qristal and PyTorch. It covers mainly the Python API.</p>
<p>Quantum machine learning at its core involves a variational quantum circuit, partitioned into two ansatzes. The first is the <em>encoding</em> ansatz, which is used to (as the name suggests) encode the input data into the circuit as the parameters of rotation gates. The second is the <em>variational</em> ansatz which also contains rotation gates; however, the parameters of these gates are optimized using classical methods to achieve a desired distribution based on the input.</p>
<p>The data-centric approach, in addition to setting it apart from algorithms of VQE and QAOA, also makes the use of gradients crucial for optimization of the variational parameters while keeping the inputs intact. This reflects the necesssity of backpropagation in classical machine learning algorithms, where one feeds back the gradients through a neural network to calculate the change in output based on the provided input[1].</p>
<section id="defining-a-variational-quantum-circuit">
<h2>Defining a variational quantum circuit<a class="headerlink" href="#defining-a-variational-quantum-circuit" title="Permalink to this headline"></a></h2>
<p>To start off, one must define a circuit using the <code class="docutils literal notranslate"><span class="pre">ParamCirc</span></code> class. The default API for this class follows a similar pattern to that of <code class="docutils literal notranslate"><span class="pre">qb.Circuit()</span></code>, and can be initialized by specifying only the number of qubits required. For example, it may be used as shown below to construct a 4-qubit circuit with an encoding ansatz and 2 repetitions of the variational ansatz:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">qb.core.optimization</span> <span class="k">as</span> <span class="nn">qbOpt</span>

<span class="n">nQubits</span> <span class="o">=</span> <span class="mi">4</span>
<span class="n">circ</span> <span class="o">=</span> <span class="n">qbOpt</span><span class="o">.</span><span class="n">ParamCirc</span><span class="p">(</span><span class="n">nQubits</span><span class="p">)</span>

<span class="c1"># encoding ansatz</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nQubits</span><span class="p">):</span>
  <span class="n">circ</span><span class="o">.</span><span class="n">rx</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="s2">&quot;input&quot;</span><span class="p">)</span>

<span class="c1"># variational ansatz, repeated twice</span>
<span class="n">nAnsatzRepetitions</span> <span class="o">=</span> <span class="mi">2</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nAnsatzRepetitions</span><span class="p">):</span>
  <span class="k">for</span> <span class="n">qubit</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nQubits</span><span class="p">):</span>
    <span class="n">circ</span><span class="o">.</span><span class="n">ry</span><span class="p">(</span><span class="n">qubit</span><span class="p">,</span> <span class="s2">&quot;variational&quot;</span><span class="p">)</span>
    <span class="n">circ</span><span class="o">.</span><span class="n">rz</span><span class="p">(</span><span class="n">qubit</span><span class="p">,</span> <span class="s2">&quot;variational&quot;</span><span class="p">)</span>
  <span class="k">for</span> <span class="n">qubit</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nQubits</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
    <span class="n">circ</span><span class="o">.</span><span class="n">cnot</span><span class="p">(</span><span class="n">qubit</span><span class="p">,</span> <span class="n">qubit</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
  <span class="n">circ</span><span class="o">.</span><span class="n">cnot</span><span class="p">(</span><span class="n">nQubits</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

<span class="n">circ</span><span class="o">.</span><span class="n">measure_all</span><span class="p">()</span>
</pre></div>
</div>
<p>By running <code class="docutils literal notranslate"><span class="pre">circ.print()</span></code>, we get the following output:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">Rx</span><span class="p">(</span><span class="n">theta_i0</span><span class="p">)</span><span class="w"> </span><span class="n">q0</span>
<span class="n">Rx</span><span class="p">(</span><span class="n">theta_i1</span><span class="p">)</span><span class="w"> </span><span class="n">q1</span>
<span class="n">Rx</span><span class="p">(</span><span class="n">theta_i2</span><span class="p">)</span><span class="w"> </span><span class="n">q2</span>
<span class="n">Rx</span><span class="p">(</span><span class="n">theta_i3</span><span class="p">)</span><span class="w"> </span><span class="n">q3</span>
<span class="n">Ry</span><span class="p">(</span><span class="n">theta_v0</span><span class="p">)</span><span class="w"> </span><span class="n">q0</span>
<span class="n">Rz</span><span class="p">(</span><span class="n">theta_v1</span><span class="p">)</span><span class="w"> </span><span class="n">q0</span>
<span class="n">Ry</span><span class="p">(</span><span class="n">theta_v2</span><span class="p">)</span><span class="w"> </span><span class="n">q1</span>
<span class="n">Rz</span><span class="p">(</span><span class="n">theta_v3</span><span class="p">)</span><span class="w"> </span><span class="n">q1</span>
<span class="n">Ry</span><span class="p">(</span><span class="n">theta_v4</span><span class="p">)</span><span class="w"> </span><span class="n">q2</span>
<span class="n">Rz</span><span class="p">(</span><span class="n">theta_v5</span><span class="p">)</span><span class="w"> </span><span class="n">q2</span>
<span class="n">Ry</span><span class="p">(</span><span class="n">theta_v6</span><span class="p">)</span><span class="w"> </span><span class="n">q3</span>
<span class="n">Rz</span><span class="p">(</span><span class="n">theta_v7</span><span class="p">)</span><span class="w"> </span><span class="n">q3</span>
<span class="n">CNOT</span><span class="w"> </span><span class="n">q3</span><span class="p">,</span><span class="n">q0</span>
<span class="n">CNOT</span><span class="w"> </span><span class="n">q0</span><span class="p">,</span><span class="n">q1</span>
<span class="n">CNOT</span><span class="w"> </span><span class="n">q1</span><span class="p">,</span><span class="n">q2</span>
<span class="n">CNOT</span><span class="w"> </span><span class="n">q2</span><span class="p">,</span><span class="n">q3</span>
<span class="n">Ry</span><span class="p">(</span><span class="n">theta_v8</span><span class="p">)</span><span class="w"> </span><span class="n">q0</span>
<span class="n">Rz</span><span class="p">(</span><span class="n">theta_v9</span><span class="p">)</span><span class="w"> </span><span class="n">q0</span>
<span class="n">Ry</span><span class="p">(</span><span class="n">theta_v10</span><span class="p">)</span><span class="w"> </span><span class="n">q1</span>
<span class="n">Rz</span><span class="p">(</span><span class="n">theta_v11</span><span class="p">)</span><span class="w"> </span><span class="n">q1</span>
<span class="n">Ry</span><span class="p">(</span><span class="n">theta_v12</span><span class="p">)</span><span class="w"> </span><span class="n">q2</span>
<span class="n">Rz</span><span class="p">(</span><span class="n">theta_v13</span><span class="p">)</span><span class="w"> </span><span class="n">q2</span>
<span class="n">Ry</span><span class="p">(</span><span class="n">theta_v14</span><span class="p">)</span><span class="w"> </span><span class="n">q3</span>
<span class="n">Rz</span><span class="p">(</span><span class="n">theta_v15</span><span class="p">)</span><span class="w"> </span><span class="n">q3</span>
<span class="n">CNOT</span><span class="w"> </span><span class="n">q3</span><span class="p">,</span><span class="n">q0</span>
<span class="n">CNOT</span><span class="w"> </span><span class="n">q0</span><span class="p">,</span><span class="n">q1</span>
<span class="n">CNOT</span><span class="w"> </span><span class="n">q1</span><span class="p">,</span><span class="n">q2</span>
<span class="n">CNOT</span><span class="w"> </span><span class="n">q2</span><span class="p">,</span><span class="n">q3</span>
<span class="n">Measure</span><span class="w"> </span><span class="n">q0</span>
<span class="n">Measure</span><span class="w"> </span><span class="n">q1</span>
<span class="n">Measure</span><span class="w"> </span><span class="n">q2</span>
<span class="n">Measure</span><span class="w"> </span><span class="n">q3</span>
</pre></div>
</div>
<p>This output shows the mapping of the input and variational rotation parameters to the respective gates. Parameters with the prefix <code class="docutils literal notranslate"><span class="pre">theta_i</span></code> are input parameters, while those with the prefix <code class="docutils literal notranslate"><span class="pre">theta_v</span></code> are variational parameters.</p>
<p>If one chooses to use one of the built-in ansatzes, such as the RDBMS query optimization ansatz, a few more inputs are required.</p>
<ul class="simple">
<li><p>Number of qubits</p></li>
<li><p>Ansatz type</p></li>
<li><p>Number of repetitions of the variational ansatz</p></li>
<li><p>Variational gates (one or more of {qb.core.String([“Rx”]),qb.core.String([“Ry”]),qb.core.String([“Rz”])}, passed as qb.core.VectorString)</p></li>
</ul>
<p>This will automatically create the structure of the full circuit, including both the encoding and variational ansatzes. For example, in the case of the RDBMS circuit, the encoding ansatz is simply an Rx gate applied across every qubit. The variational ansatz consists of the gates specified in the variational gates argument applied to every qubit, followed by a circular CNOT connection. This variational ansatz is then repeatedly applied based on the number of repetitions specified. At its core, this is the same circuit as the one shown above. However, setting this up is much simpler, and may be done as follows:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">from</span> <span class="nn">qb.core</span> <span class="kn">import</span> <span class="n">String</span><span class="p">,</span> <span class="n">VectorString</span>
<span class="n">nQubits</span> <span class="o">=</span> <span class="mi">4</span>
<span class="n">nAnsatzRepetitions</span> <span class="o">=</span> <span class="mi">2</span>
<span class="n">varGates</span> <span class="o">=</span> <span class="n">VectorString</span><span class="p">()</span>
<span class="n">varGates</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">String</span><span class="p">([</span><span class="s2">&quot;Ry&quot;</span><span class="p">]))</span>
<span class="n">varGates</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">String</span><span class="p">([</span><span class="s2">&quot;Rz&quot;</span><span class="p">]))</span>
<span class="n">circuitType</span> <span class="o">=</span> <span class="n">qbOpt</span><span class="o">.</span><span class="n">defaultAnsatzes</span><span class="o">.</span><span class="n">qrlRDBMS</span>
<span class="n">circ</span> <span class="o">=</span> <span class="n">qbOpt</span><span class="o">.</span><span class="n">ParamCirc</span><span class="p">(</span><span class="n">nQubits</span><span class="p">,</span> <span class="n">circuitType</span><span class="p">,</span> <span class="n">nAnsatzRepetitions</span><span class="p">,</span> <span class="n">varGates</span><span class="p">)</span>
</pre></div>
</div>
<p>To summarize, one should aim to use the the default initializer if more flexibility is required, and the pre-defined ansatz initializer for a simple circuit that is quick to set up. For example, with the former, one may also choose to perform <em>reuploading</em> of the input encoding gates wherein they are repeated to ensure the data fidelity is not lost during propagation through the circuit. This is not possible with the latter method (without compromising the integrity of the set circuit), and is set up as follows:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">nQubits</span> <span class="o">=</span> <span class="mi">4</span>
<span class="n">circ</span> <span class="o">=</span> <span class="n">qbOpt</span><span class="o">.</span><span class="n">ParamCirc</span><span class="p">(</span><span class="n">nQubits</span><span class="p">)</span>

<span class="c1"># encoding ansatz</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nQubits</span><span class="p">):</span>
  <span class="n">circ</span><span class="o">.</span><span class="n">rx</span><span class="p">(</span><span class="n">i</span><span class="p">,</span> <span class="s2">&quot;input&quot;</span><span class="p">)</span>

<span class="c1"># variational ansatz, repeated twice, with reuploading of encoding ansatz</span>
<span class="n">nAnsatzRepetitions</span> <span class="o">=</span> <span class="mi">2</span>
<span class="k">for</span> <span class="n">i</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nAnsatzRepetitions</span><span class="p">):</span>
  <span class="k">if</span> <span class="n">i</span> <span class="o">&gt;</span> <span class="mi">1</span><span class="p">:</span>
    <span class="n">circ</span><span class="o">.</span><span class="n">reupload</span><span class="p">()</span> <span class="c1"># reupload only after the first instance of the variational ansatz</span>
  <span class="k">for</span> <span class="n">qubit</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nQubits</span><span class="p">):</span>
    <span class="n">circ</span><span class="o">.</span><span class="n">ry</span><span class="p">(</span><span class="n">qubit</span><span class="p">,</span> <span class="s2">&quot;variational&quot;</span><span class="p">)</span>
    <span class="n">circ</span><span class="o">.</span><span class="n">rz</span><span class="p">(</span><span class="n">qubit</span><span class="p">,</span> <span class="s2">&quot;variational&quot;</span><span class="p">)</span>
  <span class="k">for</span> <span class="n">qubit</span> <span class="ow">in</span> <span class="nb">range</span><span class="p">(</span><span class="n">nQubits</span><span class="o">-</span><span class="mi">1</span><span class="p">):</span>
    <span class="n">circ</span><span class="o">.</span><span class="n">cnot</span><span class="p">(</span><span class="n">qubit</span><span class="p">,</span> <span class="n">qubit</span><span class="o">+</span><span class="mi">1</span><span class="p">)</span>
  <span class="n">circ</span><span class="o">.</span><span class="n">cnot</span><span class="p">(</span><span class="n">nQubits</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>

<span class="n">circ</span><span class="o">.</span><span class="n">measure_all</span><span class="p">()</span>
</pre></div>
</div>
</section>
<section id="using-qmlexecutor-to-assign-values-to-parameters">
<h2>Using QMLExecutor to assign values to parameters<a class="headerlink" href="#using-qmlexecutor-to-assign-values-to-parameters" title="Permalink to this headline"></a></h2>
<p>We can also use the <code class="docutils literal notranslate"><span class="pre">QMLExecutor</span></code> class to set the parameter values. This class also has functionality to handle the execution and gradient calculations of the paramterized circuit. For example, the following code sets all input parameters to <span class="math notranslate nohighlight">\(\frac{\pi}{4}\)</span> and all variational parameters to <span class="math notranslate nohighlight">\(\frac{\pi}{2}\)</span>:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">math</span>
<span class="n">inputs</span> <span class="o">=</span> <span class="n">circ</span><span class="o">.</span><span class="n">numInputs</span><span class="p">()</span><span class="o">*</span><span class="p">[</span><span class="n">math</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">4</span><span class="p">]</span>
<span class="n">params</span> <span class="o">=</span> <span class="n">circ</span><span class="o">.</span><span class="n">numParams</span><span class="p">()</span><span class="o">*</span><span class="p">[</span><span class="n">math</span><span class="o">.</span><span class="n">pi</span><span class="o">/</span><span class="mi">2</span><span class="p">]</span>
<span class="n">exec</span> <span class="o">=</span> <span class="n">QMLExecutor</span><span class="p">(</span><span class="n">circ</span><span class="p">,</span> <span class="n">inputs</span><span class="p">,</span> <span class="n">params</span><span class="p">)</span>
</pre></div>
</div>
<p>The resultant circuit will then look like:</p>
<p><img alt="" src="../_images/qml_circuit.png" /></p>
</section>
<section id="converting-the-parametrized-quantum-circuit-to-a-neural-network-layer">
<h2>Converting the parametrized quantum circuit to a neural network layer<a class="headerlink" href="#converting-the-parametrized-quantum-circuit-to-a-neural-network-layer" title="Permalink to this headline"></a></h2>
<p>Once the parametrized circuit is set up, it can be connected to PyTorch using the QB QML wrapper. More specifically, one uses the <code class="docutils literal notranslate"><span class="pre">QuantumLayer</span></code> class that subclasses <code class="docutils literal notranslate"><span class="pre">torch.nn.Module</span></code>, allowing it to act identically to a classical neural network layer in PyTorch. The inputs required are:</p>
<ul class="simple">
<li><p>The parametrized quantum circuit</p></li>
<li><p>(Optional) the initial inputs. If not set, defaults to <code class="docutils literal notranslate"><span class="pre">torch.rand(nInputParameters,</span> <span class="pre">dtype=torch.float64)</span></code>.</p></li>
<li><p>(Optional) the initial weights/variational parameters. If not set, defaults to <code class="docutils literal notranslate"><span class="pre">torch.rand(nVariationalParameters,</span> <span class="pre">dtype=torch.float64)</span></code>.</p></li>
<li><p>(Optional) the RNG seed for obtaining consistent results. If not set, defaults to <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p></li>
</ul>
<p>The execution and gradient calculations are handled internally, with the gradient being calculated using the parameter-shift rule. All in all, this means only the parametrized circuit and the layer wrapper are required to set up the quantum part of a hybrid neural network.</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">torch</span>
<span class="kn">import</span> <span class="nn">qb_qml_torch_wrapper</span> <span class="k">as</span> <span class="nn">qbML</span>

<span class="n">initWeights</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">ones</span><span class="p">(</span><span class="n">circ</span><span class="o">.</span><span class="n">numParams</span><span class="p">(),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
<span class="n">initInputs</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">circ</span><span class="o">.</span><span class="n">numInputs</span><span class="p">(),</span> <span class="n">dtype</span><span class="o">=</span><span class="n">torch</span><span class="o">.</span><span class="n">float64</span><span class="p">)</span>
<span class="n">manualSeed</span> <span class="o">=</span> <span class="mi">44</span>
<span class="n">qnn</span> <span class="o">=</span> <span class="n">qbML</span><span class="o">.</span><span class="n">QuantumLayer</span><span class="p">(</span><span class="n">circ</span><span class="p">,</span> <span class="n">initial_inputs</span><span class="o">=</span><span class="n">initInputs</span><span class="p">,</span> <span class="n">initial_weights</span><span class="o">=</span><span class="n">initWeights</span><span class="p">,</span> <span class="n">seed</span><span class="o">=</span><span class="n">manualSeed</span><span class="p">)</span>
</pre></div>
</div>
<p>An example of how these can be used to perform optimization of join orders for queries to databases is shown in  <code class="docutils literal notranslate"><span class="pre">core/examples/python/qml/RDBMS_query_optimization.py</span></code>. For a quick initialization of the hybrid NN, one can use the <code class="docutils literal notranslate"><span class="pre">torch.nn.Sequential</span></code> class. We can then put a test tensor through the model, and visualize the resultant hybrid neural network using the <code class="docutils literal notranslate"><span class="pre">torchviz</span></code> package:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">torchviz</span>

<span class="n">normLayer</span> <span class="o">=</span> <span class="n">qbML</span><span class="o">.</span><span class="n">NormLayer</span><span class="p">()</span> <span class="c1"># performs the operation x/x.max() on input tensor x</span>
<span class="n">model</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">nn</span><span class="o">.</span><span class="n">Sequential</span><span class="p">(</span><span class="n">qnn</span><span class="p">,</span> <span class="n">normLayer</span><span class="p">)</span>

<span class="n">testTensor</span> <span class="o">=</span> <span class="n">torch</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="n">circ</span><span class="o">.</span><span class="n">numInputs</span><span class="p">())</span>
<span class="n">testResult</span> <span class="o">=</span> <span class="n">model</span><span class="p">(</span><span class="n">testTensor</span><span class="p">)</span>

<span class="n">torchviz</span><span class="o">.</span><span class="n">make_dot</span><span class="p">(</span><span class="n">testresult</span><span class="p">,</span><span class="n">params</span><span class="o">=</span><span class="nb">dict</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">named_parameters</span><span class="p">()))</span><span class="o">.</span><span class="n">render</span><span class="p">(</span><span class="s2">&quot;qml_nn&quot;</span><span class="p">,</span> <span class="nb">format</span><span class="o">=</span><span class="s2">&quot;png&quot;</span><span class="p">)</span>
</pre></div>
</div>
<p>This will give us the following image:</p>
<p><img alt="" src="../_images/qml_nn.png" /></p>
<p>The <code class="docutils literal notranslate"><span class="pre">QuantumLayer</span></code> also handles backpropagation when connected to other classical layers, feeding the gradient through based on the loss. The above image can be interpreted as the graph of the neural network. One can see the output tensor (a 16-dimensional vector, <code class="docutils literal notranslate"><span class="pre">testResult</span></code>) at the bottom, based upon which backpropagation can be carried out. This tensor is the output of the normLayer, which performs the operation <span class="math notranslate nohighlight">\(\frac{\vec{x}}{\mathrm{max}(\vec{x})}\)</span> - corresponding to the <code class="docutils literal notranslate"><span class="pre">MaxBackward</span></code> and <code class="docutils literal notranslate"><span class="pre">DivBackward</span></code> nodes. Since both the max and the resultant division operation make use of the output of the previous layer (<code class="docutils literal notranslate"><span class="pre">QuantumLayer</span></code>), they are both connected to <code class="docutils literal notranslate"><span class="pre">QGradBackward</span></code>. This node then feeds the accumulated gradient back, through the <code class="docutils literal notranslate"><span class="pre">AccumulatedGrad</span></code> node(s), to the input <code class="docutils literal notranslate"><span class="pre">testTensor</span></code> (which must be discarded in the quantum case, as the input itself should not be optimized), as well as the weights - which are the variational parameters of the specified quantum circuit, and are correspondingly updated.</p>
<p>Once trained, the model with the updated weights can be saved:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">torch</span><span class="o">.</span><span class="n">save</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">state_dict</span><span class="p">(),</span> <span class="n">PATH</span><span class="p">)</span>
</pre></div>
</div>
<p>To load the model and perform inference (or continue training), set up the model as shown previously and load the state dict to provide the trained weights:</p>
<div class="highlight-python notranslate"><div class="highlight"><pre><span></span><span class="n">model</span><span class="o">.</span><span class="n">load_state_dict</span><span class="p">(</span><span class="n">torch</span><span class="o">.</span><span class="n">load</span><span class="p">(</span><span class="n">PATH</span><span class="p">))</span>
</pre></div>
</div>
<p>Using the above workflow, it is possible to create a hybrid quantum-classical machine learning workflow from any existing machine learning algorithm compatible with PyTorch. The C++ and Python APIs of <code class="docutils literal notranslate"><span class="pre">ParamCirc</span></code> and <code class="docutils literal notranslate"><span class="pre">QMLExecutor</span></code> may also be used to construct custom ML integrations with other packages.</p>
</section>
<section id="references">
<h2>References<a class="headerlink" href="#references" title="Permalink to this headline"></a></h2>
<p>[1] R. Rojas, Neural Networks: A Systematic Introduction (Springer, Berlin, 1996) pp. 161-172.</p>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="vqe.html" class="btn btn-neutral float-left" title="Variational Quantum Eigensolver (VQE)" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="../_cpp_api/library_root.html" class="btn btn-neutral float-right" title="C++ API" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2023, Quantum Brilliance Pty Ltd.</p>
  </div>

   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>