<!DOCTYPE html>
<html class="writer-html5" lang="en" >
<head>
  <meta charset="utf-8" /><meta name="generator" content="Docutils 0.17.1: http://docutils.sourceforge.net/" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Python API &mdash; Quantum SDK  documentation</title>
      <link rel="stylesheet" href="../_static/pygments.css" type="text/css" />
      <link rel="stylesheet" href="../_static/css/theme.css" type="text/css" />
      <link rel="stylesheet" href="../_static/collapsible-lists/css/tree_view.css" type="text/css" />
  <!--[if lt IE 9]>
    <script src="../_static/js/html5shiv.min.js"></script>
  <![endif]-->
  
        <script data-url_root="../" id="documentation_options" src="../_static/documentation_options.js"></script>
        <script src="../_static/jquery.js"></script>
        <script src="../_static/underscore.js"></script>
        <script src="../_static/doctools.js"></script>
        <script async="async" src="https://www.googletagmanager.com/gtag/js?id=G-215J15FW78"></script>
        <script src="../_static/js/qb_ga.js"></script>
        <script src="../_static/collapsible-lists/js/CollapsibleLists.compressed.js"></script>
        <script src="../_static/collapsible-lists/js/apply-collapsible-lists.js"></script>
        <script>window.MathJax = {"options": {"processHtmlClass": "tex2jax_process|mathjax_process|math|output_area"}}</script>
        <script defer="defer" src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
    <script src="../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../genindex.html" />
    <link rel="search" title="Search" href="../search.html" />
    <link rel="prev" title="Typedef qb::StatePrepFuncCType" href="../_cpp_api/typedef_circuit__builder_8hpp_1a3a836b4117e2cd67fc1980ad99cb2443.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search" >

          
          
          <a href="../index.html" class="icon icon-home">
            Quantum SDK
              <img src="../_static/qb_logo.png" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Basic Usage</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="getting_started.html">Getting started</a></li>
<li class="toctree-l1"><a class="reference internal" href="examples.html">Examples</a></li>
<li class="toctree-l1"><a class="reference internal" href="cli.html">Command-line interface</a></li>
<li class="toctree-l1"><a class="reference internal" href="quantum_computing.html">Quantum Computing</a></li>
<li class="toctree-l1"><a class="reference internal" href="noise_models.html">Noise models</a></li>
<li class="toctree-l1"><a class="reference internal" href="noise_models.html#user-defined-noise-models">User defined noise models</a></li>
<li class="toctree-l1"><a class="reference internal" href="vqe.html">Variational Quantum Eigensolver (VQE)</a></li>
<li class="toctree-l1"><a class="reference internal" href="qml.html">Quantum Machine Learning (QML)</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Source Code Documentation</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../_cpp_api/library_root.html">C++ API</a></li>
<li class="toctree-l1 current"><a class="current reference internal" href="#">Python API</a><ul>
<li class="toctree-l2"><a class="reference internal" href="#the-session-class">The session class</a></li>
<li class="toctree-l2"><a class="reference internal" href="#the-circuit-class">The Circuit class</a></li>
<li class="toctree-l2"><a class="reference internal" href="#noise-modelling">Noise Modelling</a></li>
<li class="toctree-l2"><a class="reference internal" href="#placement">Placement</a><ul>
<li class="toctree-l3"><a class="reference internal" href="#noise-aware-placement">Noise-aware placement</a></li>
<li class="toctree-l3"><a class="reference internal" href="#swap-based-placement">Swap-based placement</a></li>
</ul>
</li>
</ul>
</li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../index.html">Quantum SDK</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../index.html" class="icon icon-home" aria-label="Home"></a></li>
      <li class="breadcrumb-item active">Python API</li>
      <li class="wy-breadcrumbs-aside">
            <a href="../_sources/rst/python_autodoc.rst.txt" rel="nofollow"> View page source</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section id="python-api">
<h1>Python API<a class="headerlink" href="#python-api" title="Permalink to this headline"></a></h1>
<section id="the-session-class">
<h2>The session class<a class="headerlink" href="#the-session-class" title="Permalink to this headline"></a></h2>
<p>The <cite>session</cite> class provides a way to set up the experiment table.</p>
<p>You can use the experiment table to run a list of quantum circuits under different conditions, such as number of measurement shots, backends, parameters, etc.</p>
<dl class="py class">
<dt class="sig sig-object py" id="core.session">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">core.</span></span><span class="sig-name descname"><span class="pre">session</span></span><a class="headerlink" href="#core.session" title="Permalink to this definition"></a></dt>
<dd><dl class="py property">
<dt class="sig sig-object py" id="core.session.acc">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">acc</span></span><a class="headerlink" href="#core.session.acc" title="Permalink to this definition"></a></dt>
<dd><p>acc:</p>
<p>Valid settings: aer | tnqvm</p>
<p>Select a back-end simulator. The single setting applies globally to all infiles, all instrings, and random circuits.</p>
<p>accs:</p>
<p>Valid settings: [[aer|tnqvm, …], [aer|tnqvm, …]]</p>
<p>The lead dimension’s element 0 matches the vector of infiles, element 1 matches the vector of instrings, element 2 matches the vector of random depths.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="core.session.accs">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">accs</span></span><a class="headerlink" href="#core.session.accs" title="Permalink to this definition"></a></dt>
<dd><p>acc:</p>
<p>Valid settings: aer | tnqvm</p>
<p>Select a back-end simulator. The single setting applies globally to all infiles, all instrings, and random circuits.</p>
<p>accs:</p>
<p>Valid settings: [[aer|tnqvm, …], [aer|tnqvm, …]]</p>
<p>The lead dimension’s element 0 matches the vector of infiles, element 1 matches the vector of instrings, element 2 matches the vector of random depths.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="core.session.aer_sim_type">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">aer_sim_type</span></span><a class="headerlink" href="#core.session.aer_sim_type" title="Permalink to this definition"></a></dt>
<dd><p>aer_sim_type:</p>
<p>Valid settings: statevector | density_matrix | matrix_product_state</p>
<p>Selects a simulation method for the AER simulator.</p>
<p>aer_sim_types:</p>
<p>A 1d-array (list) version of aer_sim_type.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="core.session.aer_sim_types">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">aer_sim_types</span></span><a class="headerlink" href="#core.session.aer_sim_types" title="Permalink to this definition"></a></dt>
<dd><p>aer_sim_type:</p>
<p>Valid settings: statevector | density_matrix | matrix_product_state</p>
<p>Selects a simulation method for the AER simulator.</p>
<p>aer_sim_types:</p>
<p>A 1d-array (list) version of aer_sim_type.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.session.aws32dm1">
<span class="sig-name descname"><span class="pre">aws32dm1</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#core.session" title="core.session"><span class="pre">core.session</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#core.session.aws32dm1" title="Permalink to this definition"></a></dt>
<dd><p>AWS Braket DM1, 32 async workers</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.session.aws32sv1">
<span class="sig-name descname"><span class="pre">aws32sv1</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#core.session" title="core.session"><span class="pre">core.session</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#core.session.aws32sv1" title="Permalink to this definition"></a></dt>
<dd><p>AWS Braket SV1, 32 async workers</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.session.aws8tn1">
<span class="sig-name descname"><span class="pre">aws8tn1</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#core.session" title="core.session"><span class="pre">core.session</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#core.session.aws8tn1" title="Permalink to this definition"></a></dt>
<dd><p>AWS Braket TN1, 8 async workers</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="core.session.aws_device">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">aws_device</span></span><a class="headerlink" href="#core.session.aws_device" title="Permalink to this definition"></a></dt>
<dd><p>aws_device:</p>
<p>Valid settings: SV1 | TN1 | DM1 | Rigetti | LocalSimulator</p>
<p>Selects an AWS Braket back-end simulator or QPU.</p>
<p>aws_devices:</p>
<p>A 1d-array (list) version of aws_device.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="core.session.aws_devices">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">aws_devices</span></span><a class="headerlink" href="#core.session.aws_devices" title="Permalink to this definition"></a></dt>
<dd><p>aws_device:</p>
<p>Valid settings: SV1 | TN1 | DM1 | Rigetti | LocalSimulator</p>
<p>Selects an AWS Braket back-end simulator or QPU.</p>
<p>aws_devices:</p>
<p>A 1d-array (list) version of aws_device.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="core.session.aws_format">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">aws_format</span></span><a class="headerlink" href="#core.session.aws_format" title="Permalink to this definition"></a></dt>
<dd><p>aws_format:</p>
<p>Valid settings: braket | openqasm3</p>
<p>Selects an AWS Braket back-end simulator or QPU language.</p>
<p>aws_formats:</p>
<p>A 1d-array (list) version of aws_device.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="core.session.aws_formats">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">aws_formats</span></span><a class="headerlink" href="#core.session.aws_formats" title="Permalink to this definition"></a></dt>
<dd><p>aws_format:</p>
<p>Valid settings: braket | openqasm3</p>
<p>Selects an AWS Braket back-end simulator or QPU language.</p>
<p>aws_formats:</p>
<p>A 1d-array (list) version of aws_device.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="core.session.aws_s3">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">aws_s3</span></span><a class="headerlink" href="#core.session.aws_s3" title="Permalink to this definition"></a></dt>
<dd><p>aws_s3:</p>
<p>Valid settings: amazon-braket-*</p>
<p>Specifies an AWS S3 bucket in which to store outputs from AWS Braket.
Must begin with the prefix: “amazon-braket-”</p>
<p>aws_s3s:</p>
<p>A 1d-array (list) version of aws_s3.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="core.session.aws_s3_path">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">aws_s3_path</span></span><a class="headerlink" href="#core.session.aws_s3_path" title="Permalink to this definition"></a></dt>
<dd><p>aws_s3_path:</p>
<p>Valid settings: see AWS documentation for S3 path name conventions.</p>
<p>Specifies a path (inside the S3 bucket specified by aws_s3) to store outputs from AWS Braket.</p>
<p>aws_s3_paths:</p>
<p>A 1d-array (list) version of aws_s3_path.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="core.session.aws_s3_paths">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">aws_s3_paths</span></span><a class="headerlink" href="#core.session.aws_s3_paths" title="Permalink to this definition"></a></dt>
<dd><p>aws_s3_path:</p>
<p>Valid settings: see AWS documentation for S3 path name conventions.</p>
<p>Specifies a path (inside the S3 bucket specified by aws_s3) to store outputs from AWS Braket.</p>
<p>aws_s3_paths:</p>
<p>A 1d-array (list) version of aws_s3_path.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="core.session.aws_s3s">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">aws_s3s</span></span><a class="headerlink" href="#core.session.aws_s3s" title="Permalink to this definition"></a></dt>
<dd><p>aws_s3:</p>
<p>Valid settings: amazon-braket-*</p>
<p>Specifies an AWS S3 bucket in which to store outputs from AWS Braket.
Must begin with the prefix: “amazon-braket-”</p>
<p>aws_s3s:</p>
<p>A 1d-array (list) version of aws_s3.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="core.session.aws_verbatim">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">aws_verbatim</span></span><a class="headerlink" href="#core.session.aws_verbatim" title="Permalink to this definition"></a></dt>
<dd><p>aws_verbatim:</p>
<p>Valid settings: true | false</p>
<p>Selects whether verbatim mode is used on AWS Braket hardware QPU (currently Rigetti).</p>
<p>aws_verbatims:</p>
<p>A 1d-array (list) version of aws_verbatim flag.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="core.session.aws_verbatims">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">aws_verbatims</span></span><a class="headerlink" href="#core.session.aws_verbatims" title="Permalink to this definition"></a></dt>
<dd><p>aws_verbatim:</p>
<p>Valid settings: true | false</p>
<p>Selects whether verbatim mode is used on AWS Braket hardware QPU (currently Rigetti).</p>
<p>aws_verbatims:</p>
<p>A 1d-array (list) version of aws_verbatim flag.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="core.session.beta">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">beta</span></span><a class="headerlink" href="#core.session.beta" title="Permalink to this definition"></a></dt>
<dd><div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This property is currently unused.</p>
</div>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="core.session.betas">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">betas</span></span><a class="headerlink" href="#core.session.betas" title="Permalink to this definition"></a></dt>
<dd><div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This property is currently unused.</p>
</div>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="core.session.circuit_optimization">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">circuit_optimization</span></span><a class="headerlink" href="#core.session.circuit_optimization" title="Permalink to this definition"></a></dt>
<dd><p>circuit_optimization:</p>
<p>List of circuit optimization passes.</p>
<p>circuit_optimizations:</p>
<p>A 1d-array (list) version of circuit_optimization.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="core.session.circuit_optimizations">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">circuit_optimizations</span></span><a class="headerlink" href="#core.session.circuit_optimizations" title="Permalink to this definition"></a></dt>
<dd><p>circuit_optimization:</p>
<p>List of circuit optimization passes.</p>
<p>circuit_optimizations:</p>
<p>A 1d-array (list) version of circuit_optimization.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="core.session.debug">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">debug</span></span><a class="headerlink" href="#core.session.debug" title="Permalink to this definition"></a></dt>
<dd><p>debug:</p>
<p>Valid settings: True | False</p>
<p>When set to True, extra debugging information will be printed.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.session.divergence">
<span class="sig-name descname"><span class="pre">divergence</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#core.session" title="core.session"><span class="pre">core.session</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#core.session.divergence" title="Permalink to this definition"></a></dt>
<dd><p>Calculate Jensen-Shannon divergence</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="core.session.include_qb">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">include_qb</span></span><a class="headerlink" href="#core.session.include_qb" title="Permalink to this definition"></a></dt>
<dd><p>include_qb:</p>
<p>A file that contains OpenQASM format gate definitions for custom Quantum Brilliance gates.</p>
<p>include_qbs:</p>
<p>Valid settings: [include_qb, …]</p>
<p>A 1d-array (list) version of session.include_qb.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="core.session.include_qbs">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">include_qbs</span></span><a class="headerlink" href="#core.session.include_qbs" title="Permalink to this definition"></a></dt>
<dd><p>include_qb:</p>
<p>A file that contains OpenQASM format gate definitions for custom Quantum Brilliance gates.</p>
<p>include_qbs:</p>
<p>Valid settings: [include_qb, …]</p>
<p>A 1d-array (list) version of session.include_qb.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="core.session.infile">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">infile</span></span><a class="headerlink" href="#core.session.infile" title="Permalink to this definition"></a></dt>
<dd><p>infile:</p>
<p>Name of a file containing (default: OpenQASM format) a quantum circuit.</p>
<p>infiles:</p>
<p>Valid settings: [infile, …]</p>
<p>A 1d-array (list) version of session.infile.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="core.session.infiles">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">infiles</span></span><a class="headerlink" href="#core.session.infiles" title="Permalink to this definition"></a></dt>
<dd><p>infile:</p>
<p>Name of a file containing (default: OpenQASM format) a quantum circuit.</p>
<p>infiles:</p>
<p>Valid settings: [infile, …]</p>
<p>A 1d-array (list) version of session.infile.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="core.session.instring">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">instring</span></span><a class="headerlink" href="#core.session.instring" title="Permalink to this definition"></a></dt>
<dd><p>instring:</p>
<p>A string that defines a circuit in OpenQASM format.  Simple example:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">__qpu__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">QBCIRCUIT</span><span class="p">(</span><span class="n">qreg</span><span class="w"> </span><span class="n">q</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">OPENQASM</span><span class="w"> </span><span class="mf">2.0</span><span class="p">;</span>
<span class="w">        </span><span class="n">include</span><span class="w"> </span><span class="s">&quot;qelib1.inc;&quot;</span>
<span class="w">        </span><span class="n">creg</span><span class="w"> </span><span class="n">c0</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
<span class="w">        </span><span class="n">creg</span><span class="w"> </span><span class="n">c1</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
<span class="w">        </span><span class="n">h</span><span class="w"> </span><span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="w">        </span><span class="n">cx</span><span class="w"> </span><span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
<span class="w">        </span><span class="n">measure</span><span class="w"> </span><span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">c0</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="w">        </span><span class="n">measure</span><span class="w"> </span><span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">c1</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="p">}</span>
</pre></div>
</div>
<p>instrings:</p>
<p>Valid settings: [instring, …]</p>
<p>A 1d-array (list) version of session.instring.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="core.session.instrings">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">instrings</span></span><a class="headerlink" href="#core.session.instrings" title="Permalink to this definition"></a></dt>
<dd><p>instring:</p>
<p>A string that defines a circuit in OpenQASM format.  Simple example:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="n">__qpu__</span><span class="w"> </span><span class="kt">void</span><span class="w"> </span><span class="n">QBCIRCUIT</span><span class="p">(</span><span class="n">qreg</span><span class="w"> </span><span class="n">q</span><span class="p">)</span><span class="w"> </span><span class="p">{</span>
<span class="w">        </span><span class="n">OPENQASM</span><span class="w"> </span><span class="mf">2.0</span><span class="p">;</span>
<span class="w">        </span><span class="n">include</span><span class="w"> </span><span class="s">&quot;qelib1.inc;&quot;</span>
<span class="w">        </span><span class="n">creg</span><span class="w"> </span><span class="n">c0</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
<span class="w">        </span><span class="n">creg</span><span class="w"> </span><span class="n">c1</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
<span class="w">        </span><span class="n">h</span><span class="w"> </span><span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="w">        </span><span class="n">cx</span><span class="w"> </span><span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span><span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
<span class="w">        </span><span class="n">measure</span><span class="w"> </span><span class="n">q</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">c0</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="w">        </span><span class="n">measure</span><span class="w"> </span><span class="n">q</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">-&gt;</span><span class="w"> </span><span class="n">c1</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>
<span class="p">}</span>
</pre></div>
</div>
<p>instrings:</p>
<p>Valid settings: [instring, …]</p>
<p>A 1d-array (list) version of session.instring.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="core.session.ir_target">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">ir_target</span></span><a class="headerlink" href="#core.session.ir_target" title="Permalink to this definition"></a></dt>
<dd><p>ir_target:</p>
<p>Input quantum circuit (core.Circuit).</p>
<p>ir_targets:</p>
<p>A 1d-array (list) version of ir_target.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="core.session.ir_targets">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">ir_targets</span></span><a class="headerlink" href="#core.session.ir_targets" title="Permalink to this definition"></a></dt>
<dd><p>ir_target:</p>
<p>Input quantum circuit (core.Circuit).</p>
<p>ir_targets:</p>
<p>A 1d-array (list) version of ir_target.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="core.session.log_enabled">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">log_enabled</span></span><a class="headerlink" href="#core.session.log_enabled" title="Permalink to this definition"></a></dt>
<dd><div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This property is currently unused.</p>
</div>
<p>log_enabled:</p>
<p>Setting this to True to enable logging to file. The single setting applies globally.</p>
<p>Valid settings: True | False</p>
<p>log_enableds:</p>
<p>Valid settings: [[True|False, …], [True|False, …]]</p>
<p>A 1d-array (list) version of log_enabled.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="core.session.log_enableds">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">log_enableds</span></span><a class="headerlink" href="#core.session.log_enableds" title="Permalink to this definition"></a></dt>
<dd><div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This property is currently unused.</p>
</div>
<p>log_enabled:</p>
<p>Setting this to True to enable logging to file. The single setting applies globally.</p>
<p>Valid settings: True | False</p>
<p>log_enableds:</p>
<p>Valid settings: [[True|False, …], [True|False, …]]</p>
<p>A 1d-array (list) version of log_enabled.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="core.session.max_bond_dimension">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">max_bond_dimension</span></span><a class="headerlink" href="#core.session.max_bond_dimension" title="Permalink to this definition"></a></dt>
<dd><p>max_bond_dimension:</p>
<p>Set the maximum bond dimension (MPS simulator). The single setting applies globally.</p>
<p>max_bond_dimensions:</p>
<p>A 1d-array (list) version of max_bond_dimension.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This is only needed if using the “tnqvm” backend accelerator.</p>
</div>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="core.session.max_bond_dimensions">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">max_bond_dimensions</span></span><a class="headerlink" href="#core.session.max_bond_dimensions" title="Permalink to this definition"></a></dt>
<dd><p>max_bond_dimension:</p>
<p>Set the maximum bond dimension (MPS simulator). The single setting applies globally.</p>
<p>max_bond_dimensions:</p>
<p>A 1d-array (list) version of max_bond_dimension.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This is only needed if using the “tnqvm” backend accelerator.</p>
</div>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="core.session.noise">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">noise</span></span><a class="headerlink" href="#core.session.noise" title="Permalink to this definition"></a></dt>
<dd><p>noise:</p>
<p>Valid settings: True | False</p>
<p>Setting this to True to enable noisy simulation (if supported by the <cite>acc</cite> backend). The single setting applies globally.</p>
<p>noises:</p>
<p>Valid settings: [[True|False, …], [True|False, …]]</p>
<p>A 1d-array (list) version of noise.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="core.session.noise_mitigation">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">noise_mitigation</span></span><a class="headerlink" href="#core.session.noise_mitigation" title="Permalink to this definition"></a></dt>
<dd><p>noise_mitigation:</p>
<p>Select a noise mitigation module.</p>
<p>noise_mitigations:</p>
<p>A 1d-array (list) version of noise_mitigation.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="core.session.noise_mitigations">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">noise_mitigations</span></span><a class="headerlink" href="#core.session.noise_mitigations" title="Permalink to this definition"></a></dt>
<dd><p>noise_mitigation:</p>
<p>Select a noise mitigation module.</p>
<p>noise_mitigations:</p>
<p>A 1d-array (list) version of noise_mitigation.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="core.session.noise_model">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">noise_model</span></span><a class="headerlink" href="#core.session.noise_model" title="Permalink to this definition"></a></dt>
<dd><p>noise_model:</p>
<p>Set the noise model to be used in subsequent simulations.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Requires setting: noise = True (to have effect)</p>
</div>
<p>The default (built in) model is a simple depolarizing noise model on all qubits.</p>
<p>Users may make their own instances of the NoiseModel class (or make an instance of the
default and modify it), and then assign that model to this property.  See examples/python/noise_model*.py.</p>
<p>If the Qristal Emulator is installed, the following additional models are available and
can be accessed by specifying the relevant model name as a string passed to the constructor
of the NoiseModel class:</p>
<p>“qb-nm1” : 4x4 NV centres in x-y grid, 3 qubits per NV centre</p>
<p>“qb-nm2” : 8x8 NV centres in x-y grid, 1 qubit per NV centre, nearest x and nearest y connectivity</p>
<p>“qb-qdk1” : 1 NV centre with 2 qubits, fidelities tuned to match deployed device</p>
<p>“qb-dqc2” : 1 NV centre with 2 qubits, fidelities tuned to match lab-based device</p>
<p>noise_models:</p>
<p>A 1d-array (list) version of noise_model.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="core.session.noise_models">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">noise_models</span></span><a class="headerlink" href="#core.session.noise_models" title="Permalink to this definition"></a></dt>
<dd><p>noise_model:</p>
<p>Set the noise model to be used in subsequent simulations.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>Requires setting: noise = True (to have effect)</p>
</div>
<p>The default (built in) model is a simple depolarizing noise model on all qubits.</p>
<p>Users may make their own instances of the NoiseModel class (or make an instance of the
default and modify it), and then assign that model to this property.  See examples/python/noise_model*.py.</p>
<p>If the Qristal Emulator is installed, the following additional models are available and
can be accessed by specifying the relevant model name as a string passed to the constructor
of the NoiseModel class:</p>
<p>“qb-nm1” : 4x4 NV centres in x-y grid, 3 qubits per NV centre</p>
<p>“qb-nm2” : 8x8 NV centres in x-y grid, 1 qubit per NV centre, nearest x and nearest y connectivity</p>
<p>“qb-qdk1” : 1 NV centre with 2 qubits, fidelities tuned to match deployed device</p>
<p>“qb-dqc2” : 1 NV centre with 2 qubits, fidelities tuned to match lab-based device</p>
<p>noise_models:</p>
<p>A 1d-array (list) version of noise_model.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="core.session.noises">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">noises</span></span><a class="headerlink" href="#core.session.noises" title="Permalink to this definition"></a></dt>
<dd><p>noise:</p>
<p>Valid settings: True | False</p>
<p>Setting this to True to enable noisy simulation (if supported by the <cite>acc</cite> backend). The single setting applies globally.</p>
<p>noises:</p>
<p>Valid settings: [[True|False, …], [True|False, …]]</p>
<p>A 1d-array (list) version of noise.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="core.session.nooptimise">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">nooptimise</span></span><a class="headerlink" href="#core.session.nooptimise" title="Permalink to this definition"></a></dt>
<dd><p>nooptimise:</p>
<p>Valid settings: True | False</p>
<p>Setting this to True to disable circuit optimization. The single setting applies globally.</p>
<p>nooptimises:</p>
<p>Valid settings: [[True|False, …], [True|False, …]]</p>
<p>A 1d-array (list) version of nooptimise.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="core.session.nooptimises">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">nooptimises</span></span><a class="headerlink" href="#core.session.nooptimises" title="Permalink to this definition"></a></dt>
<dd><p>nooptimise:</p>
<p>Valid settings: True | False</p>
<p>Setting this to True to disable circuit optimization. The single setting applies globally.</p>
<p>nooptimises:</p>
<p>Valid settings: [[True|False, …], [True|False, …]]</p>
<p>A 1d-array (list) version of nooptimise.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="core.session.noplacement">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">noplacement</span></span><a class="headerlink" href="#core.session.noplacement" title="Permalink to this definition"></a></dt>
<dd><p>noplacement:</p>
<p>Valid settings: True | False</p>
<p>Setting this to True to disable circuit placement. The single setting applies globally.</p>
<p>noplacements:</p>
<p>Valid settings: [[True|False, …], [True|False, …]]</p>
<p>A 1d-array (list) version of noplacement.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="core.session.noplacements">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">noplacements</span></span><a class="headerlink" href="#core.session.noplacements" title="Permalink to this definition"></a></dt>
<dd><p>noplacement:</p>
<p>Valid settings: True | False</p>
<p>Setting this to True to disable circuit placement. The single setting applies globally.</p>
<p>noplacements:</p>
<p>Valid settings: [[True|False, …], [True|False, …]]</p>
<p>A 1d-array (list) version of noplacement.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="core.session.nosim">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">nosim</span></span><a class="headerlink" href="#core.session.nosim" title="Permalink to this definition"></a></dt>
<dd><p>nosim:</p>
<p>Valid settings: True | False</p>
<p>Setting this to True to disable circuit simulation. The single setting applies globally.</p>
<p>nosims:</p>
<p>Valid settings: [[True|False, …], [True|False, …]]</p>
<p>A 1d-array (list) version of nosim.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="core.session.nosims">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">nosims</span></span><a class="headerlink" href="#core.session.nosims" title="Permalink to this definition"></a></dt>
<dd><p>nosim:</p>
<p>Valid settings: True | False</p>
<p>Setting this to True to disable circuit simulation. The single setting applies globally.</p>
<p>nosims:</p>
<p>Valid settings: [[True|False, …], [True|False, …]]</p>
<p>A 1d-array (list) version of nosim.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="core.session.notiming">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">notiming</span></span><a class="headerlink" href="#core.session.notiming" title="Permalink to this definition"></a></dt>
<dd><div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This property is currently unused.</p>
</div>
<p>notiming:</p>
<p>Valid settings: True | False</p>
<p>Setting this to True to disable timing estimation. The single setting applies globally.</p>
<p>notimings:</p>
<p>Valid settings: [[True|False, …], [True|False, …]]</p>
<p>A 1d-array (list) version of notiming.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="core.session.notimings">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">notimings</span></span><a class="headerlink" href="#core.session.notimings" title="Permalink to this definition"></a></dt>
<dd><div class="admonition warning">
<p class="admonition-title">Warning</p>
<p>This property is currently unused.</p>
</div>
<p>notiming:</p>
<p>Valid settings: True | False</p>
<p>Setting this to True to disable timing estimation. The single setting applies globally.</p>
<p>notimings:</p>
<p>Valid settings: [[True|False, …], [True|False, …]]</p>
<p>A 1d-array (list) version of notiming.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="core.session.num_threads">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">num_threads</span></span><a class="headerlink" href="#core.session.num_threads" title="Permalink to this definition"></a></dt>
<dd><p>The number of threads in the QB SDK thread pool</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>num_threads</p>
</dd>
</dl>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="core.session.out_count">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">out_count</span></span><a class="headerlink" href="#core.session.out_count" title="Permalink to this definition"></a></dt>
<dd><p>out_count:</p>
<p>After calling session.run(), the counts from running sn shots are stored in session.out_count, using a dictionary where the keys are state label bits interpreted as BCD (MSB format).</p>
<p>out_counts:</p>
<p>A 1d-array (list) version of session.out_count.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="core.session.out_counts">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">out_counts</span></span><a class="headerlink" href="#core.session.out_counts" title="Permalink to this definition"></a></dt>
<dd><p>out_count:</p>
<p>After calling session.run(), the counts from running sn shots are stored in session.out_count, using a dictionary where the keys are state label bits interpreted as BCD (MSB format).</p>
<p>out_counts:</p>
<p>A 1d-array (list) version of session.out_count.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="core.session.out_divergence">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">out_divergence</span></span><a class="headerlink" href="#core.session.out_divergence" title="Permalink to this definition"></a></dt>
<dd><p>out_divergence:</p>
<p>After calling session.divergence(), the Jensen-Shannon divergence between session.out_count and session.output_amplitude is calculated and stored session.out_divergence.</p>
<p>out_divergences:</p>
<p>A 1d-array (list) version of session.out_divergence.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="core.session.out_divergences">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">out_divergences</span></span><a class="headerlink" href="#core.session.out_divergences" title="Permalink to this definition"></a></dt>
<dd><p>out_divergence:</p>
<p>After calling session.divergence(), the Jensen-Shannon divergence between session.out_count and session.output_amplitude is calculated and stored session.out_divergence.</p>
<p>out_divergences:</p>
<p>A 1d-array (list) version of session.out_divergence.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="core.session.out_double_qubit_gate_qty">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">out_double_qubit_gate_qty</span></span><a class="headerlink" href="#core.session.out_double_qubit_gate_qty" title="Permalink to this definition"></a></dt>
<dd><p>out_double_qubit_gate_qty:</p>
<p>After calling session.profile(), the circuit in session.out_transpiled_circuit is processed and the count of the number of two-qubit gates is stored as session.out_double_qubit_gate_qty, using a dictionary where the keys are integers corresponding to qubit indexes.</p>
<p>out_double_qubit_gate_qtys:</p>
<p>A 1d-array (list) version of session.out_double_qubit_gate_qty.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="core.session.out_double_qubit_gate_qtys">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">out_double_qubit_gate_qtys</span></span><a class="headerlink" href="#core.session.out_double_qubit_gate_qtys" title="Permalink to this definition"></a></dt>
<dd><p>out_double_qubit_gate_qty:</p>
<p>After calling session.profile(), the circuit in session.out_transpiled_circuit is processed and the count of the number of two-qubit gates is stored as session.out_double_qubit_gate_qty, using a dictionary where the keys are integers corresponding to qubit indexes.</p>
<p>out_double_qubit_gate_qtys:</p>
<p>A 1d-array (list) version of session.out_double_qubit_gate_qty.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="core.session.out_qbjson">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">out_qbjson</span></span><a class="headerlink" href="#core.session.out_qbjson" title="Permalink to this definition"></a></dt>
<dd><p>out_qbjson:</p>
<p>Shows JSON data sent to QB hardware.  Note: session.run() must be called first.</p>
<p>out_qbjsons:</p>
<p>A 1d-array (list) version of session.out_qbjson.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="core.session.out_qbjsons">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">out_qbjsons</span></span><a class="headerlink" href="#core.session.out_qbjsons" title="Permalink to this definition"></a></dt>
<dd><p>out_qbjson:</p>
<p>Shows JSON data sent to QB hardware.  Note: session.run() must be called first.</p>
<p>out_qbjsons:</p>
<p>A 1d-array (list) version of session.out_qbjson.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="core.session.out_qobj">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">out_qobj</span></span><a class="headerlink" href="#core.session.out_qobj" title="Permalink to this definition"></a></dt>
<dd><p>out_qobj:</p>
<p>When acc=’aer’, the .qobj JSON input used by a standalone Aer installation is stored in out_qobj.  Note: session.run() must be called first.</p>
<p>out_qobjs:</p>
<p>A 1d-array (list) version of session.out_qobj.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="core.session.out_qobjs">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">out_qobjs</span></span><a class="headerlink" href="#core.session.out_qobjs" title="Permalink to this definition"></a></dt>
<dd><p>out_qobj:</p>
<p>When acc=’aer’, the .qobj JSON input used by a standalone Aer installation is stored in out_qobj.  Note: session.run() must be called first.</p>
<p>out_qobjs:</p>
<p>A 1d-array (list) version of session.out_qobj.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="core.session.out_raw">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">out_raw</span></span><a class="headerlink" href="#core.session.out_raw" title="Permalink to this definition"></a></dt>
<dd><p>out_raw:</p>
<p>After calling session.run(), the counts from running sn shots are stored in session.out_raw, using a JSON format.</p>
<p>out_raws:</p>
<p>A 1d-array (list) version of session.out_raw.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="core.session.out_raws">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">out_raws</span></span><a class="headerlink" href="#core.session.out_raws" title="Permalink to this definition"></a></dt>
<dd><p>out_raw:</p>
<p>After calling session.run(), the counts from running sn shots are stored in session.out_raw, using a JSON format.</p>
<p>out_raws:</p>
<p>A 1d-array (list) version of session.out_raw.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="core.session.out_single_qubit_gate_qty">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">out_single_qubit_gate_qty</span></span><a class="headerlink" href="#core.session.out_single_qubit_gate_qty" title="Permalink to this definition"></a></dt>
<dd><p>out_single_qubit_gate_qty:</p>
<p>After calling session.profile(), the circuit in session.out_transpiled_circuit is processed and the count of the number of single qubit gates is stored as session.out_single_qubit_gate_qty, using a dictionary where the keys are integers corresponding to qubit indexes.</p>
<p>out_single_qubit_gate_qtys:</p>
<p>A 1d-array (list) version of session.out_single_qubit_gate_qty.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="core.session.out_single_qubit_gate_qtys">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">out_single_qubit_gate_qtys</span></span><a class="headerlink" href="#core.session.out_single_qubit_gate_qtys" title="Permalink to this definition"></a></dt>
<dd><p>out_single_qubit_gate_qty:</p>
<p>After calling session.profile(), the circuit in session.out_transpiled_circuit is processed and the count of the number of single qubit gates is stored as session.out_single_qubit_gate_qty, using a dictionary where the keys are integers corresponding to qubit indexes.</p>
<p>out_single_qubit_gate_qtys:</p>
<p>A 1d-array (list) version of session.out_single_qubit_gate_qty.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="core.session.out_total_init_maxgate_readout_time">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">out_total_init_maxgate_readout_time</span></span><a class="headerlink" href="#core.session.out_total_init_maxgate_readout_time" title="Permalink to this definition"></a></dt>
<dd><p>out_total_init_maxgate_readout_time:</p>
<p>After calling session.profile(), the circuit in in session.out_transpiled_circuit is processed and timing estimates taken to perform the required number of shots [sn] are stored as session.out_total_init_maxgate_readout_time.</p>
<p>It uses a dictionary with the following keys [integer]:</p>
<blockquote>
<div><p>0: total, in ms;</p>
<p>1: initialisation time component, in ms;</p>
<p>2: max depth gate time component, in ms;</p>
<p>3: readout time component, in ms;</p>
<p>4: total (classically simulated time), in ms;</p>
<p>5: PC transfer to controller time, in ms.</p>
</div></blockquote>
<p>out_total_init_maxgate_readout_times:</p>
<p>A 1d-array (list) version of session.out_total_init_maxgate_readout_time.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="core.session.out_total_init_maxgate_readout_times">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">out_total_init_maxgate_readout_times</span></span><a class="headerlink" href="#core.session.out_total_init_maxgate_readout_times" title="Permalink to this definition"></a></dt>
<dd><p>out_total_init_maxgate_readout_time:</p>
<p>After calling session.profile(), the circuit in in session.out_transpiled_circuit is processed and timing estimates taken to perform the required number of shots [sn] are stored as session.out_total_init_maxgate_readout_time.</p>
<p>It uses a dictionary with the following keys [integer]:</p>
<blockquote>
<div><p>0: total, in ms;</p>
<p>1: initialisation time component, in ms;</p>
<p>2: max depth gate time component, in ms;</p>
<p>3: readout time component, in ms;</p>
<p>4: total (classically simulated time), in ms;</p>
<p>5: PC transfer to controller time, in ms.</p>
</div></blockquote>
<p>out_total_init_maxgate_readout_times:</p>
<p>A 1d-array (list) version of session.out_total_init_maxgate_readout_time.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="core.session.out_transpiled_circuit">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">out_transpiled_circuit</span></span><a class="headerlink" href="#core.session.out_transpiled_circuit" title="Permalink to this definition"></a></dt>
<dd><p>out_transpiled_circuit:</p>
<p>After calling session.run(), the transpiled version of session.instring is stored as session.out_transpiled_circuit.</p>
<p>out_transpiled_circuits:</p>
<p>A 1d-array (list) version of session.out_transpiled_circuit.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="core.session.out_transpiled_circuits">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">out_transpiled_circuits</span></span><a class="headerlink" href="#core.session.out_transpiled_circuits" title="Permalink to this definition"></a></dt>
<dd><p>out_transpiled_circuit:</p>
<p>After calling session.run(), the transpiled version of session.instring is stored as session.out_transpiled_circuit.</p>
<p>out_transpiled_circuits:</p>
<p>A 1d-array (list) version of session.out_transpiled_circuit.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="core.session.out_z_op_expect">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">out_z_op_expect</span></span><a class="headerlink" href="#core.session.out_z_op_expect" title="Permalink to this definition"></a></dt>
<dd><p>out_z_op_expect:</p>
<p>After calling run(), the Z-operator expectation value determined from counts in respective states is stored in out_z_op_expects, using a dictionary where the keys are integers, and currently only key:0 is used.</p>
<p>out_z_op_expects:</p>
<p>A 1d-array (list) version of out_z_op_expect.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="core.session.out_z_op_expects">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">out_z_op_expects</span></span><a class="headerlink" href="#core.session.out_z_op_expects" title="Permalink to this definition"></a></dt>
<dd><p>out_z_op_expect:</p>
<p>After calling run(), the Z-operator expectation value determined from counts in respective states is stored in out_z_op_expects, using a dictionary where the keys are integers, and currently only key:0 is used.</p>
<p>out_z_op_expects:</p>
<p>A 1d-array (list) version of out_z_op_expect.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="core.session.output_amplitude">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">output_amplitude</span></span><a class="headerlink" href="#core.session.output_amplitude" title="Permalink to this definition"></a></dt>
<dd><p>output_amplitude:</p>
<p>Set the amplitudes for Jensen-Shannon divergence calculation. The single setting applies globally.</p>
<p>output_amplitudes:</p>
<p>A 1d-array (list) version of output_amplitude.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="core.session.output_amplitudes">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">output_amplitudes</span></span><a class="headerlink" href="#core.session.output_amplitudes" title="Permalink to this definition"></a></dt>
<dd><p>output_amplitude:</p>
<p>Set the amplitudes for Jensen-Shannon divergence calculation. The single setting applies globally.</p>
<p>output_amplitudes:</p>
<p>A 1d-array (list) version of output_amplitude.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="core.session.output_oqm_enabled">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">output_oqm_enabled</span></span><a class="headerlink" href="#core.session.output_oqm_enabled" title="Permalink to this definition"></a></dt>
<dd><p>output_oqm_enabled:</p>
<p>Valid settings: True | False</p>
<p>Setting this to True to enable circuit timing and resource estimation. The single setting applies globally.</p>
<p>output_oqm_enableds:</p>
<p>Valid settings: [[True|False, …], [True|False, …]]</p>
<p>A 1d-array (list) version of output_oqm_enabled.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="core.session.output_oqm_enableds">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">output_oqm_enableds</span></span><a class="headerlink" href="#core.session.output_oqm_enableds" title="Permalink to this definition"></a></dt>
<dd><p>output_oqm_enabled:</p>
<p>Valid settings: True | False</p>
<p>Setting this to True to enable circuit timing and resource estimation. The single setting applies globally.</p>
<p>output_oqm_enableds:</p>
<p>Valid settings: [[True|False, …], [True|False, …]]</p>
<p>A 1d-array (list) version of output_oqm_enabled.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="core.session.placement">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">placement</span></span><a class="headerlink" href="#core.session.placement" title="Permalink to this definition"></a></dt>
<dd><p>placement:</p>
<p>Valid settings: “swap-shortest-path” | “noise-aware”</p>
<p>Setting the method to map from logical qubits to the physical qubits of the device that will be used to carry them. The single setting applies globally to all infiles and all instrings.
Default: “swap-shortest-path”</p>
<p>placements:</p>
<p>Valid settings: [[“swap-shortest-path” | “noise-aware”, …], [“swap-shortest-path” | “noise-aware”, …]]</p>
<p>The lead dimension’s element 0 matches the vector of infiles, element 1 matches the vector of instrings, element 2 matches the vector of randoms.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="core.session.placements">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">placements</span></span><a class="headerlink" href="#core.session.placements" title="Permalink to this definition"></a></dt>
<dd><p>placement:</p>
<p>Valid settings: “swap-shortest-path” | “noise-aware”</p>
<p>Setting the method to map from logical qubits to the physical qubits of the device that will be used to carry them. The single setting applies globally to all infiles and all instrings.
Default: “swap-shortest-path”</p>
<p>placements:</p>
<p>Valid settings: [[“swap-shortest-path” | “noise-aware”, …], [“swap-shortest-path” | “noise-aware”, …]]</p>
<p>The lead dimension’s element 0 matches the vector of infiles, element 1 matches the vector of instrings, element 2 matches the vector of randoms.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.session.qb12">
<span class="sig-name descname"><span class="pre">qb12</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#core.session" title="core.session"><span class="pre">core.session</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#core.session.qb12" title="Permalink to this definition"></a></dt>
<dd><p>Quantum Brilliance 12-qubit defaults</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="core.session.qn">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">qn</span></span><a class="headerlink" href="#core.session.qn" title="Permalink to this definition"></a></dt>
<dd><p>qn:</p>
<p>Number of qubits. The single setting applies globally.</p>
<p>qns:</p>
<p>A 1d-array (list) version of qn.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="core.session.qns">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">qns</span></span><a class="headerlink" href="#core.session.qns" title="Permalink to this definition"></a></dt>
<dd><p>qn:</p>
<p>Number of qubits. The single setting applies globally.</p>
<p>qns:</p>
<p>A 1d-array (list) version of qn.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="core.session.qpu_config">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">qpu_config</span></span><a class="headerlink" href="#core.session.qpu_config" title="Permalink to this definition"></a></dt>
<dd><p>qpu_config:</p>
<p>A JSON file that contains configuration data for Quantum Brilliance hardware.</p>
<p>qpu_configs:</p>
<p>Valid settings: [qpu_config, …]</p>
<p>A 1d-array (list) version of session.qpu_config.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="core.session.qpu_configs">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">qpu_configs</span></span><a class="headerlink" href="#core.session.qpu_configs" title="Permalink to this definition"></a></dt>
<dd><p>qpu_config:</p>
<p>A JSON file that contains configuration data for Quantum Brilliance hardware.</p>
<p>qpu_configs:</p>
<p>Valid settings: [qpu_config, …]</p>
<p>A 1d-array (list) version of session.qpu_config.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="core.session.quil1">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">quil1</span></span><a class="headerlink" href="#core.session.quil1" title="Permalink to this definition"></a></dt>
<dd><p>quil1:</p>
<p>Valid settings: True | False</p>
<p>Setting this to True causes circuits to be interpreted in Quil 1.0 format. The single setting applies globally to all infiles and all instrings.</p>
<p>quil1s:</p>
<p>Valid settings: [[True|False, …], [True|False, …]]</p>
<p>The lead dimension’s element 0 matches the vector of infiles, element 1 matches the vector of instrings, element 2 matches the vector of randoms.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="core.session.quil1s">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">quil1s</span></span><a class="headerlink" href="#core.session.quil1s" title="Permalink to this definition"></a></dt>
<dd><p>quil1:</p>
<p>Valid settings: True | False</p>
<p>Setting this to True causes circuits to be interpreted in Quil 1.0 format. The single setting applies globally to all infiles and all instrings.</p>
<p>quil1s:</p>
<p>Valid settings: [[True|False, …], [True|False, …]]</p>
<p>The lead dimension’s element 0 matches the vector of infiles, element 1 matches the vector of instrings, element 2 matches the vector of randoms.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="core.session.random">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">random</span></span><a class="headerlink" href="#core.session.random" title="Permalink to this definition"></a></dt>
<dd><p>random:</p>
<p>Circuit depth of the random circuit to use as input. The single setting applies globally.</p>
<p>randoms:</p>
<p>A 1d-array (list) version of random.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="core.session.randoms">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">randoms</span></span><a class="headerlink" href="#core.session.randoms" title="Permalink to this definition"></a></dt>
<dd><p>random:</p>
<p>Circuit depth of the random circuit to use as input. The single setting applies globally.</p>
<p>randoms:</p>
<p>A 1d-array (list) version of random.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.session.reset_contrasts">
<span class="sig-name descname"><span class="pre">reset_contrasts</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#core.session" title="core.session"><span class="pre">core.session</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#core.session.reset_contrasts" title="Permalink to this definition"></a></dt>
<dd><p>QB hardware contrast thresholds reset</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="core.session.rn">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">rn</span></span><a class="headerlink" href="#core.session.rn" title="Permalink to this definition"></a></dt>
<dd><p>rn:</p>
<p>Number of repetitions. The single setting applies globally.</p>
<p>rns:</p>
<p>A 1d-array (list) version of rn.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="core.session.rns">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">rns</span></span><a class="headerlink" href="#core.session.rns" title="Permalink to this definition"></a></dt>
<dd><p>rn:</p>
<p>Number of repetitions. The single setting applies globally.</p>
<p>rns:</p>
<p>A 1d-array (list) version of rn.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.session.run">
<span class="sig-name descname"><span class="pre">run</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#core.session" title="core.session"><span class="pre">core.session</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#core.session.run" title="Permalink to this definition"></a></dt>
<dd><p>Execute all declared quantum circuits under all conditions</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.session.run_async">
<span class="sig-name descname"><span class="pre">run_async</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#core.session" title="core.session"><span class="pre">core.session</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">arg0</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">arg1</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">core.Handle</span></span></span><a class="headerlink" href="#core.session.run_async" title="Permalink to this definition"></a></dt>
<dd><p>run_async(i,j) : Launch the execution of circuit i, condition j asynchronously.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.session.run_complete">
<span class="sig-name descname"><span class="pre">run_complete</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#core.session" title="core.session"><span class="pre">core.session</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">arg0</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">arg1</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#core.session.run_complete" title="Permalink to this definition"></a></dt>
<dd><p>run_complete(i,j) : Check if the execution of circuit i, condition j has been completed.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.session.runit">
<span class="sig-name descname"><span class="pre">runit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#core.session" title="core.session"><span class="pre">core.session</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">arg0</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">arg1</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#core.session.runit" title="Permalink to this definition"></a></dt>
<dd><p>runit(i,j) : Execute circuit i, condition j</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="core.session.seed">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">seed</span></span><a class="headerlink" href="#core.session.seed" title="Permalink to this definition"></a></dt>
<dd><p>seed:</p>
<p>Set the random seed value.</p>
<p>seeds:</p>
<p>A 1d-array (list) version of seed.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="core.session.seeds">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">seeds</span></span><a class="headerlink" href="#core.session.seeds" title="Permalink to this definition"></a></dt>
<dd><p>seed:</p>
<p>Set the random seed value.</p>
<p>seeds:</p>
<p>A 1d-array (list) version of seed.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.session.set_contrasts">
<span class="sig-name descname"><span class="pre">set_contrasts</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#core.session" title="core.session"><span class="pre">core.session</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">arg0</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">arg1</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">arg2</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#core.session.set_contrasts" title="Permalink to this definition"></a></dt>
<dd><p>QB hardware contrast thresholds: init, qubit[0] final readout, qubit[1] final readout</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.session.set_parallel_run_config">
<span class="sig-name descname"><span class="pre">set_parallel_run_config</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#core.session" title="core.session"><span class="pre">core.session</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">arg0</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#core.session.set_parallel_run_config" title="Permalink to this definition"></a></dt>
<dd><p>Set the parallel execution configuration</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="core.session.sn">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">sn</span></span><a class="headerlink" href="#core.session.sn" title="Permalink to this definition"></a></dt>
<dd><p>sn:</p>
<p>Number of measurement shots. The single setting applies globally.</p>
<p>sns:</p>
<p>A 1d-array (list) version of sn.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="core.session.sns">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">sns</span></span><a class="headerlink" href="#core.session.sns" title="Permalink to this definition"></a></dt>
<dd><p>sn:</p>
<p>Number of measurement shots. The single setting applies globally.</p>
<p>sns:</p>
<p>A 1d-array (list) version of sn.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="core.session.svd_cutoff">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">svd_cutoff</span></span><a class="headerlink" href="#core.session.svd_cutoff" title="Permalink to this definition"></a></dt>
<dd><p>svd_cutoff:</p>
<p>Set the SVD cutoff threshold value (MPS simulator). The single setting applies globally.</p>
<p>svd_cutoffs:</p>
<p>A 1d-array (list) version of svd_cutoff.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This is only needed if using the “tnqvm” backend accelerator.</p>
</div>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="core.session.svd_cutoffs">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">svd_cutoffs</span></span><a class="headerlink" href="#core.session.svd_cutoffs" title="Permalink to this definition"></a></dt>
<dd><p>svd_cutoff:</p>
<p>Set the SVD cutoff threshold value (MPS simulator). The single setting applies globally.</p>
<p>svd_cutoffs:</p>
<p>A 1d-array (list) version of svd_cutoff.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>This is only needed if using the “tnqvm” backend accelerator.</p>
</div>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="core.session.theta">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">theta</span></span><a class="headerlink" href="#core.session.theta" title="Permalink to this definition"></a></dt>
<dd><p>theta:</p>
<p>Angle variables (theta) to invoke the input parameterized quantum circuit with. The single setting applies globally.</p>
<p>thetas:</p>
<p>A 1d-array (list) version of theta.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="core.session.thetas">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">thetas</span></span><a class="headerlink" href="#core.session.thetas" title="Permalink to this definition"></a></dt>
<dd><p>theta:</p>
<p>Angle variables (theta) to invoke the input parameterized quantum circuit with. The single setting applies globally.</p>
<p>thetas:</p>
<p>A 1d-array (list) version of theta.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="core.session.xasm">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">xasm</span></span><a class="headerlink" href="#core.session.xasm" title="Permalink to this definition"></a></dt>
<dd><p>xasm:</p>
<p>Valid settings: True | False</p>
<p>Setting this to True causes circuits to be interpreted in XASM format.  The single setting applies globally to all infiles and all instrings.</p>
<p>xasms:</p>
<p>Valid settings: [[True|False, …], [True|False, …]]</p>
<p>The lead dimension’s element 0 matches the vector of infiles, element 1 matches the vector of instrings, element 2 matches the vector of randoms.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="core.session.xasms">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">xasms</span></span><a class="headerlink" href="#core.session.xasms" title="Permalink to this definition"></a></dt>
<dd><p>xasm:</p>
<p>Valid settings: True | False</p>
<p>Setting this to True causes circuits to be interpreted in XASM format.  The single setting applies globally to all infiles and all instrings.</p>
<p>xasms:</p>
<p>Valid settings: [[True|False, …], [True|False, …]]</p>
<p>The lead dimension’s element 0 matches the vector of infiles, element 1 matches the vector of instrings, element 2 matches the vector of randoms.</p>
</dd></dl>

</dd></dl>

</section>
<section id="the-circuit-class">
<h2>The Circuit class<a class="headerlink" href="#the-circuit-class" title="Permalink to this headline"></a></h2>
<p>The <cite>Circuit</cite> class represents a quantum circuit, i.e., an ordered sequence of [quantum gates and measurements](<a class="reference external" href="https://qristal.readthedocs.io/en/latest/rst/quantum_computing.html">https://qristal.readthedocs.io/en/latest/rst/quantum_computing.html</a>).</p>
<p>In addition to elementary gates, it also supports pre-built circuit templates for commonly-used algorithms, such as Quantum Fourier Transform (QFT), algebraic circuits, etc.</p>
<dl class="py class">
<dt class="sig sig-object py" id="core.Circuit">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">core.</span></span><span class="sig-name descname"><span class="pre">Circuit</span></span><a class="headerlink" href="#core.Circuit" title="Permalink to this definition"></a></dt>
<dd><dl class="py method">
<dt class="sig sig-object py" id="core.Circuit.amcu">
<span class="sig-name descname"><span class="pre">amcu</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#core.Circuit" title="core.Circuit"><span class="pre">core.Circuit</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">U</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">object</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">qubits_control</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.int32</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">qubits_ancilla</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.int32</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#core.Circuit.amcu" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>Multi Controlled Unitary With Ancilla</p>
</div></blockquote>
<p>This method decomposes a multi-controlled unitary into Toffoli gates
and the unitary itself, with the use of ancilla qubits. With N control
qubits there should be N-1 ancilla. The resulting instructions are added
to the circuit (AMCU gate).</p>
<p>Parameters:</p>
<ul class="simple">
<li><p><strong>U</strong> The unitary operation [CircuitBuilder]</p></li>
<li><p><strong>qubits_control</strong> The indices of the control qubits [list of int]</p></li>
<li><p><strong>qubits_ancilla</strong> The indices of the ancilla qubits [list of int]</p></li>
</ul>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.Circuit.amplitude_amplification">
<span class="sig-name descname"><span class="pre">amplitude_amplification</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#core.Circuit" title="core.Circuit"><span class="pre">core.Circuit</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">oracle</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">object</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">state_prep</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">object</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">power</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#core.Circuit.amplitude_amplification" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>Amplitude Amplification</p>
</div></blockquote>
<p>This method adds a number of Grovers operators to the circuit.</p>
<p>Grovers operators are used to amplify the amplitude of some desired
subspace of your quantum state.</p>
<p>Parameters:</p>
<ul class="simple">
<li><p><strong>oracle</strong> The oracle circuit O that marks the good subspace [CircuitBuilder]</p></li>
<li><p><strong>state_prep</strong> The circuit A used to prepare the input state [CircuitBuilder]</p></li>
<li><p><strong>power</strong> The number of Grovers operators to append to the circuit [int]</p></li>
</ul>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.Circuit.append">
<span class="sig-name descname"><span class="pre">append</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#core.Circuit" title="core.Circuit"><span class="pre">core.Circuit</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">other</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#core.Circuit" title="core.Circuit"><span class="pre">core.Circuit</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#core.Circuit.append" title="Permalink to this definition"></a></dt>
<dd><p>Append the ‘other’ quantum circuit to this circuit.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.Circuit.canonical_ae">
<span class="sig-name descname"><span class="pre">canonical_ae</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#core.Circuit" title="core.Circuit"><span class="pre">core.Circuit</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">state_prep</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">object</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">grover_op</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">object</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">precision</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_state_prep_qubits</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_trial_qubits</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">precision_qubits</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.int32</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">array([],</span> <span class="pre">dtype=int32)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">trial_qubits</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.int32</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">array([],</span> <span class="pre">dtype=int32)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">no_state_prep</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#core.Circuit.canonical_ae" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>Canonical Amplitude Estimation</p>
</div></blockquote>
<p>This method adds the canonical version of Quantum Amplitude Estimation
(QAE) to the circuit.</p>
<p>Given a quantum state split into a good subspace and a bad subspace,
the QAE sub-routine provides a k-bit approximation to the amplitude of
the good subspace, a.</p>
<p>QAE works by using the Grovers operator Q, which amplifies the amplitude
of the good subspace, as the unitary input to a Quantum Phase Estimation
routine.</p>
<p>Parameters:</p>
<ul class="simple">
<li><p><strong>state_prep</strong> The circuit A used to prepare the input state [CircuitBuilder]</p></li>
<li><p><strong>grover_op</strong> The circuit for the Grovers operator Q for the good subspace [CircuitBuilder]</p></li>
<li><p><strong>precision</strong> The number of bits k used to approximate the amplitude [int]</p></li>
<li><p><strong>num_state_prep_qubits</strong> The number of qubits acted on by the state_prep circuit A [int]</p></li>
<li><p><strong>num_trial_qubits</strong> The number of qubits acted on by the grover_op circuit Q [int]</p></li>
<li><p><strong>trial_qubits</strong> The indices of the qubits acted on by the grover_op circuit Q [list of int]</p></li>
<li><p><strong>precision_qubits</strong> The indices of the qubits used to store the approximate amplitude [list of int]</p></li>
<li><p><strong>no_state_prep</strong> If true, assumes the state is already prepared in the appropriate register [bool]</p></li>
</ul>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.Circuit.ccx">
<span class="sig-name descname"><span class="pre">ccx</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#core.Circuit" title="core.Circuit"><span class="pre">core.Circuit</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">ctrl_idx1</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ctrl_idx2</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target_idx</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#core.Circuit.ccx" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>Toffoli gate</p>
</div></blockquote>
<p>This method adds a Toffoli gate (CCX) to the circuit.</p>
<p>The CCX gate performs an X gate on the target qubit
conditional on the two control qubits being in the 1 state.</p>
<p>Parameters:</p>
<ul class="simple">
<li><p><strong>ctrl_idx1</strong> the index of the first control qubit [int]</p></li>
<li><p><strong>ctrl_idx2</strong> the index of the second control qubit [int]</p></li>
<li><p><strong>target_idx</strong> the index of the target qubit [int]</p></li>
</ul>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.Circuit.ch">
<span class="sig-name descname"><span class="pre">ch</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#core.Circuit" title="core.Circuit"><span class="pre">core.Circuit</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">ctrl_idx</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target_idx</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#core.Circuit.ch" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>CH gate</p>
</div></blockquote>
<p>This method adds a controlled-H (CH) gate to the circuit.</p>
<p>The CH gate performs an H gate on the target qubit
conditional on the control qubit being in the 1 state.</p>
<ul class="simple">
<li><p><strong>ctrl_idx</strong> the index of the control qubit [int]</p></li>
<li><p><strong>target_idx</strong> the index of the target qubit [int]</p></li>
</ul>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.Circuit.cnot">
<span class="sig-name descname"><span class="pre">cnot</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#core.Circuit" title="core.Circuit"><span class="pre">core.Circuit</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">ctrl_idx</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target_idx</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#core.Circuit.cnot" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>CNOT gate</p>
</div></blockquote>
<p>This method adds a controlled-X (CNOT) gate to the circuit.</p>
<p>The CNOT gate performs an X gate on the target qubit
conditional on the control qubit being in the 1 state.</p>
<p>Parameters:</p>
<ul class="simple">
<li><p><strong>ctrl_idx</strong> the index of the control qubit [int]</p></li>
<li><p><strong>target_idx</strong> the index of the target qubit [int]</p></li>
</ul>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.Circuit.comparator">
<span class="sig-name descname"><span class="pre">comparator</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#core.Circuit" title="core.Circuit"><span class="pre">core.Circuit</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">best_score</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_scoring_qubits</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">trial_score_qubits</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.int32</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">array([],</span> <span class="pre">dtype=int32)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">flag_qubit</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">-</span> <span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">best_score_qubits</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.int32</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">array([],</span> <span class="pre">dtype=int32)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ancilla_qubits</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.int32</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">array([],</span> <span class="pre">dtype=int32)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">is_LSB</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">controls_on</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.int32</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">array([],</span> <span class="pre">dtype=int32)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">controls_off</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.int32</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">array([],</span> <span class="pre">dtype=int32)</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#core.Circuit.comparator" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>Comparator</p>
</div></blockquote>
<p>This method adds a quantum bit string comparator to the circuit.</p>
<p>The quantum bit string comparator is used to compare the values of two
bit string. If the trial score is greater than the best score, the flag
qubit is flipped.</p>
<p>Parameters:</p>
<ul class="simple">
<li><p><strong>best_score</strong> The score we are comparing strings to [int]</p></li>
<li><p><strong>num_scoring_qubits</strong> The number of qubits used to encode the scores [int]</p></li>
<li><p><strong>trial_score_qubits</strong> The indices of the qubits encoding the trial states [list of int]</p></li>
<li><p><strong>flag_qubit</strong> The index of the flag qubit which is flipped whenever trial score &gt; BestScore [int]</p></li>
<li><p><strong>best_score_qubits</strong> The indices of the qubits encoding the BestScore value [list of int]</p></li>
<li><p><strong>ancilla_qubits</strong> The indices of the ancilla qubits required for the comparator circuit, if num_scoring_qubits = N we need 3N-1 ancilla [list of int]</p></li>
<li><p><strong>is_LSB</strong> Indicates that the trial scores are encoded with LSB ordering [bool]</p></li>
<li><p><strong>controls_on</strong> The indices of any qubits that should be “on” controls (i.e. circuit executed if qubit = 1) [list of int]</p></li>
<li><p><strong>controls_off</strong> The indices of any qubits that should be “off” controls (i.e. circuit executed if qubit = 0) [list of int]</p></li>
</ul>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.Circuit.comparator_as_oracle">
<span class="sig-name descname"><span class="pre">comparator_as_oracle</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#core.Circuit" title="core.Circuit"><span class="pre">core.Circuit</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">best_score</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_scoring_qubits</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">trial_score_qubits</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.int32</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">array([],</span> <span class="pre">dtype=int32)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">flag_qubit</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">-</span> <span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">best_score_qubits</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.int32</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">array([],</span> <span class="pre">dtype=int32)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ancilla_qubits</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.int32</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">array([],</span> <span class="pre">dtype=int32)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">is_LSB</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">controls_on</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.int32</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">array([],</span> <span class="pre">dtype=int32)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">controls_off</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.int32</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">array([],</span> <span class="pre">dtype=int32)</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#core.Circuit.comparator_as_oracle" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>Comparator as Oracle</p>
</div></blockquote>
<p>This method adds a quantum bit string comparator oracle to the circuit.</p>
<p>The quantum bit string comparator is used to add a negative phase to any
trial state whose bit string value is greater than the state being
compared to. In this way it can be used as an oracle in a Grovers
operator that amplifies higher scoring strings. This may be useful in
many search problems.</p>
<p>Parameters:</p>
<ul class="simple">
<li><p><strong>best_score</strong> The score we are comparing strings to [int]</p></li>
<li><p><strong>num_scoring_qubits</strong> The number of qubits used to encode the scores [int]</p></li>
<li><p><strong>trial_score_qubits</strong> The indices of the qubits encoding the trial states [list of int]</p></li>
<li><p><strong>flag_qubit</strong> The index of the flag qubit which acquires a negative phase whenever trial score &gt; BestScore [int]</p></li>
<li><p><strong>best_score_qubits</strong> The indices of the qubits encoding the BestScore value [list of int]</p></li>
<li><p><strong>ancilla_qubits</strong> The indices of the ancilla qubits required for the comparator circuit, if num_scoring_qubits = N we need 3N-1 ancilla [list of int]</p></li>
<li><p><strong>is_LSB</strong> Indicates that the trial scores are encoded with LSB ordering [bool]</p></li>
<li><p><strong>controls_on</strong> The indices of any qubits that should be “on” controls (i.e. circuit executed if qubit = 1) [list of int]</p></li>
<li><p><strong>controls_off</strong> The indices of any qubits that should be “off” controls (i.e. circuit executed if qubit = 0) [list of int]</p></li>
</ul>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.Circuit.compare_beam_oracle">
<span class="sig-name descname"><span class="pre">compare_beam_oracle</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#core.Circuit" title="core.Circuit"><span class="pre">core.Circuit</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">q0</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">q1</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">q2</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">FA</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.int32</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">FB</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.int32</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">SA</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.int32</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">SB</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.int32</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">array([],</span> <span class="pre">dtype=int32)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">simplified</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#core.Circuit.compare_beam_oracle" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>Compare Beam Oracle</p>
</div></blockquote>
<p>This method adds a compare beam oracle to the circuit.</p>
<p>This method is required for the quantum decoder algorithm.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.Circuit.compare_gt">
<span class="sig-name descname"><span class="pre">compare_gt</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#core.Circuit" title="core.Circuit"><span class="pre">core.Circuit</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">qubits_a</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.int32</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">qubits_b</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.int32</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">qubit_flag</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">qubit_ancilla</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">is_LSB</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#core.Circuit.compare_gt" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>Compare Greater Than</p>
</div></blockquote>
<p>This method adds a greater-than comparator to the circuit.</p>
<p>Given two binary strings a and b, this comparator flips a flag qubit
whenever a&gt;b. This method uses far less ancilla than the more general
comparator method provided.</p>
<p>Parameters:</p>
<ul class="simple">
<li><p><strong>qubits_a</strong> The indices of the qubits encoding a [list of int]</p></li>
<li><p><strong>qubits_b</strong> The indices of the qubits encoding b [list of int]</p></li>
<li><p><strong>qubit_flag</strong> The index of the flag qubit that is flipped whenever a&gt;b [int]</p></li>
<li><p><strong>qubit_ancilla</strong> The index of the single ancilla qubit required [int]</p></li>
<li><p><strong>is_LSB</strong> Indicates that the trial scores are encoded with LSB ordering [bool]</p></li>
</ul>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.Circuit.controlled_multiplication">
<span class="sig-name descname"><span class="pre">controlled_multiplication</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#core.Circuit" title="core.Circuit"><span class="pre">core.Circuit</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">qubit_ancilla</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.int32</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">qubits_a</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.int32</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">qubits_b</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.int32</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">qubits_result</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">is_LSB</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">controls_on</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.int32</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">array([],</span> <span class="pre">dtype=int32)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">controls_off</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.int32</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">array([],</span> <span class="pre">dtype=int32)</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#core.Circuit.controlled_multiplication" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>Controlled Multiplication</p>
</div></blockquote>
<p>This method adds a controlled Multiplication to the circuit.</p>
<p>Performs a Multiplication operation on a and b if an only if the
controls are satisfied.</p>
<p>Parameters:</p>
<ul class="simple">
<li><p><strong>qubits_a</strong> the indices of the qubits encoding a [list of int]</p></li>
<li><p><strong>qubits_b</strong> the indices of the qubits encoding b [list of int]</p></li>
<li><p><strong>qubits_result</strong> the indices of the qubits that will ecode the multiplication result [list of int]</p></li>
<li><p><strong>qubits_ancilla</strong> the index of the single required ancilla [int]</p></li>
<li><p><strong>is_LSB</strong> Indicates that the trial scores are encoded with LSB ordering [bool]</p></li>
<li><p><strong>controls_on</strong> The indices of any qubits that should be “on” controls (i.e. circuit executed if qubit = 1) [list of int]</p></li>
<li><p><strong>controls_off</strong> The indices of any qubits that should be “off” controls (i.e. circuit executed if qubit = 0) [list of int]</p></li>
</ul>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.Circuit.controlled_proper_fraction_division">
<span class="sig-name descname"><span class="pre">controlled_proper_fraction_division</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#core.Circuit" title="core.Circuit"><span class="pre">core.Circuit</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">qubits_numerator</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.int32</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">qubits_denominator</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.int32</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">qubits_fraction</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.int32</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">qubits_ancilla</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.int32</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">controls_on</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.int32</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">array([],</span> <span class="pre">dtype=int32)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">controls_off</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.int32</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">array([],</span> <span class="pre">dtype=int32)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">is_LSB</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#core.Circuit.controlled_proper_fraction_division" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>Controlled Proper Fraction Division</p>
</div></blockquote>
<p>This method adds a controlled proper fraction division to the circuit.</p>
<p>Performs a PFD operation on a and b if an only if the controls are
satisfied.</p>
<p>Parameters:</p>
<ul class="simple">
<li><p><strong>qubits_numerator</strong> the indices of the qubits encoding the numerator [list of int]</p></li>
<li><p><strong>qubits_denominator</strong> the indices of the qubits encoding the denominator [list of int]</p></li>
<li><p><strong>qubits_fraction</strong> the indices of the qubits that will ecode the division result [list of int]</p></li>
<li><p><strong>qubit_ancilla</strong> the index of the required ancilla [list of int]</p></li>
<li><p><strong>controls_on</strong> The indices of any qubits that should be “on” controls (i.e. circuit executed if qubit = 1) [list of int]</p></li>
<li><p><strong>controls_off</strong> The indices of any qubits that should be “off” controls (i.e. circuit executed if qubit = 0) [list of int]</p></li>
<li><p><strong>is_LSB</strong> Indicates that the trial scores are encoded with LSB ordering [bool]</p></li>
</ul>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.Circuit.controlled_ripple_carry_adder">
<span class="sig-name descname"><span class="pre">controlled_ripple_carry_adder</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#core.Circuit" title="core.Circuit"><span class="pre">core.Circuit</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">qubits_adder</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.int32</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">qubits_sum</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.int32</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">c_in</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">flags_on</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.int32</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">array([],</span> <span class="pre">dtype=int32)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">flags_off</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.int32</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">array([],</span> <span class="pre">dtype=int32)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">no_overflow</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#core.Circuit.controlled_ripple_carry_adder" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>Controlled Addition</p>
</div></blockquote>
<p>This method adds a controlled ripple carry adder to the circuit.</p>
<p>Performs a RippleAdd operation on adder_bits and sum_bits if and only
if the controls are satisfied.</p>
<p>Parameters:</p>
<ul class="simple">
<li><p><strong>qubits_adder</strong> the indices of the qubits encoding adder_bits [list of int]</p></li>
<li><p><strong>qubits_sum</strong> the indices of the qubits encoding sum_bits [list of int]</p></li>
<li><p><strong>c_in</strong> the index of the carry-in bit [int]</p></li>
<li><p><strong>flags_on</strong> The indices of any qubits that should be “on” controls (i.e. circuit executed if qubit = 1) [list of int]</p></li>
<li><p><strong>flags_off</strong> The indices of any qubits that should be “off” controls (i.e. circuit executed if qubit = 0) [list of int]</p></li>
<li><p><strong>no_overflow</strong> Indicates that the total of the addition can be encoded on the same number of qubits as sum_bits without overflowing [bool]</p></li>
</ul>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.Circuit.controlled_subtraction">
<span class="sig-name descname"><span class="pre">controlled_subtraction</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#core.Circuit" title="core.Circuit"><span class="pre">core.Circuit</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">qubits_larger</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.int32</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">qubits_smaller</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.int32</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">controls_on</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.int32</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">array([],</span> <span class="pre">dtype=int32)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">controls_off</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.int32</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">array([],</span> <span class="pre">dtype=int32)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">is_LSB</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">qubit_ancilla</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">-</span> <span class="pre">1</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#core.Circuit.controlled_subtraction" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>Controlled Subtraction</p>
</div></blockquote>
<p>This method adds a controlled subtraction to the circuit.</p>
<p>Performs a subtraction operation on a and b if an only if the
controls are satisfied.</p>
<p>Parameters:</p>
<ul class="simple">
<li><p><strong>qubits_larger</strong> the indices of the qubits encoding the larger value [list of int]</p></li>
<li><p><strong>qubits_smaller</strong> the indices of the qubits encoding the smaller value [list of int]</p></li>
<li><p><strong>controls_on</strong> The indices of any qubits that should be “on” controls (i.e. circuit executed if qubit = 1) [list of int]</p></li>
<li><p><strong>controls_off</strong> The indices of any qubits that should be “off” controls (i.e. circuit executed if qubit = 0) [list of int]</p></li>
<li><p><strong>is_LSB</strong> Indicates that the trial scores are encoded with LSB ordering [bool]</p></li>
<li><p><strong>qubit_ancilla</strong> the index of the required ancilla [list of int]</p></li>
</ul>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.Circuit.controlled_swap">
<span class="sig-name descname"><span class="pre">controlled_swap</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#core.Circuit" title="core.Circuit"><span class="pre">core.Circuit</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">qubits_a</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.int32</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">qubits_b</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.int32</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">flags_on</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.int32</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">array([],</span> <span class="pre">dtype=int32)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">flags_off</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.int32</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">array([],</span> <span class="pre">dtype=int32)</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#core.Circuit.controlled_swap" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>Controlled SWAP</p>
</div></blockquote>
<p>This method adds a controlled SWAP to the circuit.</p>
<p>Performs a SWAP operation on a and b if an only if the controls are
satisfied.</p>
<p>Parameters:</p>
<ul class="simple">
<li><p><strong>qubits_a</strong> the indices of the qubits encoding a [list of int]</p></li>
<li><p><strong>qubits_b</strong> the indices of the qubits encoding b [list of int]</p></li>
<li><p><strong>flags_on</strong> The indices of any qubits that should be “on” controls (i.e. circuit executed if qubit = 1) [list of int]</p></li>
<li><p><strong>flags_off</strong> The indices of any qubits that should be “off” controls (i.e. circuit executed if qubit = 0) [list of int]</p></li>
</ul>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.Circuit.cphase">
<span class="sig-name descname"><span class="pre">cphase</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#core.Circuit" title="core.Circuit"><span class="pre">core.Circuit</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">ctrl_idx</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target_idx</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">theta</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#core.Circuit.cphase" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>CPhase gate</p>
</div></blockquote>
<p>This method adds a controlled-U1 (CPhase) gate to the circuit.</p>
<p>The CPHase gate performs a U1(theta) gate on the target qubit
conditional on the control qubit being in the 1 state.</p>
<p>Parameters:</p>
<ul class="simple">
<li><p><strong>ctrl_idx</strong> the index of the control qubit [int]</p></li>
<li><p><strong>target_idx</strong> the index of the target qubit [int]</p></li>
<li><p><strong>theta</strong> the value of the phase [double]</p></li>
</ul>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.Circuit.cz">
<span class="sig-name descname"><span class="pre">cz</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#core.Circuit" title="core.Circuit"><span class="pre">core.Circuit</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">ctrl_idx</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target_idx</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#core.Circuit.cz" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>CZ gate</p>
</div></blockquote>
<p>This method adds a controlled-Z (CZ) gate to the circuit.</p>
<p>The CZ gate performs a Z gate on the target qubit
conditional on the control qubit being in the 1 state.</p>
<p>Parameters:</p>
<ul class="simple">
<li><p><strong>ctrl_idx</strong> the index of the control qubit [int]</p></li>
<li><p><strong>target_idx</strong> the index of the target qubit [int]</p></li>
</ul>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.Circuit.efficient_encoding">
<span class="sig-name descname"><span class="pre">efficient_encoding</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#core.Circuit" title="core.Circuit"><span class="pre">core.Circuit</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">scoring_function</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Callable</span><span class="p"><span class="pre">[</span></span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">int</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_state_qubits</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_scoring_qubits</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">state_qubits</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.int32</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">array([],</span> <span class="pre">dtype=int32)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">scoring_qubits</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.int32</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">array([],</span> <span class="pre">dtype=int32)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">is_LSB</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_ancilla</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">qubits_init_flags</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.int32</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">array([],</span> <span class="pre">dtype=int32)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">flag_integer</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">0</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#core.Circuit.efficient_encoding" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>Efficient Encoding</p>
</div></blockquote>
<p>This method adds an efficient encoding routine to the circuit.</p>
<p>Given a lookup function f that assigns a score to each binary string,
we entangle each string to its score. Rather than
encoding states sequentially we cut down on the
amount of X gates required by instead following the Gray code ordering
of states.</p>
<p>This module can optionally also flag strings of a certain value.</p>
<p>Parameters:</p>
<ul class="simple">
<li><p><strong>scoring_function</strong> A function that inputs the integer value of a binary string and outputs its score [func(int) -&gt; int]</p></li>
<li><p><strong>num_state_qubits</strong> The number of qubits encoding the strings [int]</p></li>
<li><p><strong>num_scoring_qubits</strong> The number of qubits encoding the scores [int]</p></li>
<li><p><strong>state_qubits</strong> The indices of the qubits encoding the strings [list of int]</p></li>
<li><p><strong>scoring_qubits</strong> The indices of the qubits encoding the scores [list of int]</p></li>
<li><p><strong>is_LSB</strong> Indicates that the trial scores are encoded with LSB ordering [bool]</p></li>
<li><p><strong>use_ancilla</strong> Indicates that ancilla qubits can be used to decompose MCX gates [bool]</p></li>
<li><p><strong>qubits_init_flag</strong> The indices of any flag qubits [list of int]</p></li>
<li><p><strong>flag_integer</strong> The integer value of binary strings that should be flagged [int]</p></li>
</ul>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.Circuit.equality_checker">
<span class="sig-name descname"><span class="pre">equality_checker</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#core.Circuit" title="core.Circuit"><span class="pre">core.Circuit</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">qubits_a</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.int32</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">qubits_b</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.int32</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">flag</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">use_ancilla</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">False</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">qubits_ancilla</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.int32</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">array([],</span> <span class="pre">dtype=int32)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">controls_on</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.int32</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">array([],</span> <span class="pre">dtype=int32)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">controls_off</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.int32</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">array([],</span> <span class="pre">dtype=int32)</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#core.Circuit.equality_checker" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>Equality Checker</p>
</div></blockquote>
<p>This method adds an equality checker to the circuit.</p>
<p>Given two input bitstrings a and b the equality checker is
used to flip a flag qubit whenever a=b.</p>
<p>Parameters:</p>
<ul class="simple">
<li><p><strong>qubits_a</strong> the indices of the qubits encoding a [list of int]</p></li>
<li><p><strong>qubits_b</strong> the indices of the qubits encoding b [list of int]</p></li>
<li><p><strong>flag</strong> the index of the flag qubit that gets flipped whenever a=b [int]</p></li>
<li><p><strong>use_ancilla</strong> Indicates that ancilla qubits can be used to decompose MCX gates [bool]</p></li>
<li><p><strong>qubits_ancilla</strong> The indices of the qubits to be used as ancilla qubits if use_ancilla=true [list of int]</p></li>
<li><p><strong>controls_on</strong> The indices of any qubits that should be “on” controls (i.e. circuit executed if qubit = 1) [list of int]</p></li>
<li><p><strong>controls_off</strong> The indices of any qubits that should be “off” controls (i.e. circuit executed if qubit = 0) [list of int]</p></li>
</ul>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.Circuit.execute">
<span class="sig-name descname"><span class="pre">execute</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#core.Circuit" title="core.Circuit"><span class="pre">core.Circuit</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">QPU</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'qpp'</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">NUM_SHOTS</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1024</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">NUM_QUBITS</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">-</span> <span class="pre">1</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">str</span></span></span><a class="headerlink" href="#core.Circuit.execute" title="Permalink to this definition"></a></dt>
<dd><p>Run the circuit.</p>
<p>This method is used to pass the circuit to an accelerator backend
for execution.</p>
<p>The optional parameters are:</p>
<ul class="simple">
<li><p><strong>QPU</strong> The accelerator name [string]</p></li>
<li><p><strong>NUM_SHOTS</strong> The number of shots to use [int]</p></li>
<li><p><strong>NUM_QUBITS</strong> The number of qubits required for the circuit [int]</p></li>
</ul>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.Circuit.exponent">
<span class="sig-name descname"><span class="pre">exponent</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#core.Circuit" title="core.Circuit"><span class="pre">core.Circuit</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">qubits_log</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.int32</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">array([],</span> <span class="pre">dtype=int32)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">qubits_exponent</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.int32</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">array([],</span> <span class="pre">dtype=int32)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">qubits_ancilla</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.int32</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">array([],</span> <span class="pre">dtype=int32)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">min_significance</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">1</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">is_LSB</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">bool</span></span></span><a class="headerlink" href="#core.Circuit.exponent" title="Permalink to this definition"></a></dt>
<dd><p>Exponent Base 2</p>
<p>This method adds an exponent to the circuit. This is used to replace some value
by its exponent base 2.</p>
<p>Parameters:</p>
<ul class="simple">
<li><p><strong>qubits_log</strong> the indices of the qubits encoding the original value [list of int]</p></li>
<li><p><strong>qubits_exponent</strong> the indices of the qubits used to store the result [list of int]</p></li>
<li><p><strong>qubits_ancilla</strong> the indices of the required ancilla qubits [list of int]</p></li>
<li><p><strong>min_significance</strong> the accuracy cutoff [int]</p></li>
<li><p><strong>is_LSB</strong> indicates LSB ordering is used [bool]</p></li>
</ul>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.Circuit.exponential_search">
<span class="sig-name descname"><span class="pre">exponential_search</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#core.Circuit" title="core.Circuit"><span class="pre">core.Circuit</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">method</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">state_prep</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">object</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">oracle</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Callable</span><span class="p"><span class="pre">[</span></span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><a class="reference internal" href="#core.Circuit" title="core.Circuit"><span class="pre">core.Circuit</span></a><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">best_score</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">f_score</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Callable</span><span class="p"><span class="pre">[</span></span><span class="p"><span class="pre">[</span></span><span class="pre">int</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">int</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">total_num_qubits</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">qubits_string</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.int32</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">total_metric</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.int32</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">qpu</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'qpp'</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">int</span></span></span><a class="headerlink" href="#core.Circuit.exponential_search" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>Exponential Search</p>
</div></blockquote>
<p>This method sets up and executes the exponential search routine.</p>
<p>Exponential search is a way to perform amplitude estimation when the
size of the “good” subspace is unknown (so the number of Grovers
operators to use is unknown).</p>
<p>We implement three variants:
- canonical exponential search is a specific “guess and check” method
- MLQAE exponential search uses MLQAE to first estimate the size of the good subspace then perform regular amplitude estimation with the appropriate number of Grovers operators
- CQAE exponential search uses canonical QAE to first estimate the size of the good subspace then perform regular amplitude estimation with the appropriate number of Grovers operators</p>
<p>Parameters:</p>
<ul class="simple">
<li><p><strong>method</strong> indicates which method to use. Options are “canonical”, “MLQAE”, “CQAE” [string]</p></li>
<li><p><strong>state_prep</strong> a function which produces the state prep circuit [StatePrepFuncCType]</p></li>
<li><p><strong>oracle</strong> a function which produces the oracle circuit that marks the good subspace [OracleFuncCType]</p></li>
<li><p><strong>best_score</strong> the current best score [int]</p></li>
<li><p><strong>f_score</strong> a function that returns a 1 if the input binary string has value greater than the current best score and 0 otherwise [func(int)-&gt;int]</p></li>
<li><p><strong>total_num_qubits</strong> total number of qubits [int]</p></li>
<li><p><strong>qubits_string</strong> the indices of the qubits encoding the strings [list of int]</p></li>
<li><p><strong>total_metric</strong> the indices of the qubits encoding the string scores after any required pre-processing of qubits_metric (required by decoder) [list of int]</p></li>
<li><p><strong>qpu</strong> the name of the accelerator used to execute the algorithm [string]</p></li>
</ul>
<p>Returns: a better score if found, otherwise returns the current best
score</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.Circuit.generalised_mcx">
<span class="sig-name descname"><span class="pre">generalised_mcx</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#core.Circuit" title="core.Circuit"><span class="pre">core.Circuit</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">target</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">controls_on</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.int32</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">array([],</span> <span class="pre">dtype=int32)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">controls_off</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.int32</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">array([],</span> <span class="pre">dtype=int32)</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#core.Circuit.generalised_mcx" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>Generalised MCX</p>
</div></blockquote>
<p>This method adds a generalised MCX gate to the circuit.</p>
<p>By generalised MCX we mean that we allow the control qubits to be
conditional on being off or conditional on being on.</p>
<p>Parameters:</p>
<ul class="simple">
<li><p><strong>target</strong> The index of the target qubit [int]</p></li>
<li><p><strong>controls_on</strong> The indices of any qubits that should be “on” controls (i.e. circuit executed if qubit = 1) [list of int]</p></li>
<li><p><strong>controls_off</strong> The indices of any qubits that should be “off” controls (i.e. circuit executed if qubit = 0) [list of int]</p></li>
</ul>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.Circuit.h">
<span class="sig-name descname"><span class="pre">h</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#core.Circuit" title="core.Circuit"><span class="pre">core.Circuit</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">idx</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#core.Circuit.h" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>Hadamard gate</p>
</div></blockquote>
<p>This method adds a Hadamard (H) gate to the circuit.</p>
<p>Parameters:</p>
<ul class="simple">
<li><p><strong>idx</strong> the index of the qubit being acted on [int]</p></li>
</ul>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.Circuit.inverse_circuit">
<span class="sig-name descname"><span class="pre">inverse_circuit</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#core.Circuit" title="core.Circuit"><span class="pre">core.Circuit</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">circ</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">object</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#core.Circuit.inverse_circuit" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>Inverse Circuit</p>
</div></blockquote>
<p>This method adds the inverse of a circuit to the current circuit.</p>
<p>Given some collection of unitary operations,</p>
<p>U = U_NU_{N-1}…U_2U_1</p>
<p>this method appends the inverse to the circuit:</p>
<p>U^{-1} = U_1dg U_2dg…U_{N-1}dg U_Ndg</p>
<p>This may be useful for un-computing ancilla or for constructing Grovers
operators.</p>
<p>Parameters:</p>
<ul class="simple">
<li><p><strong>circ</strong> The circuit whose inverse we want to add to the current circuit [CircuitBuilder]</p></li>
</ul>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.Circuit.iqft">
<span class="sig-name descname"><span class="pre">iqft</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#core.Circuit" title="core.Circuit"><span class="pre">core.Circuit</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">qubits</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.int32</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#core.Circuit.iqft" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>Inverse Quantum Fourier Transform</p>
</div></blockquote>
<p>This method adds the inverse of the Quantum Fourier Transform (IQFT) to
the circuit.</p>
<p>Parameters:</p>
<ul class="simple">
<li><p><strong>qubits</strong> the indices of the target qubits [list of int]</p></li>
</ul>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.Circuit.mcx">
<span class="sig-name descname"><span class="pre">mcx</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#core.Circuit" title="core.Circuit"><span class="pre">core.Circuit</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">ctrl_inds</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.int32</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">target_idx</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#core.Circuit.mcx" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>MCX gate</p>
</div></blockquote>
<p>This method adds a multi-controlled X (MCX) gate to the circuit.</p>
<p>The MCX gate performs an X gate on the target qubit
conditional on all control qubits being in the 1 state.</p>
<p>Parameters:</p>
<ul class="simple">
<li><p><strong>ctrl_inds</strong> the indices of the control qubits [list of int]</p></li>
<li><p><strong>target_idx</strong> the index of the target qubit [int]</p></li>
</ul>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.Circuit.measure">
<span class="sig-name descname"><span class="pre">measure</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#core.Circuit" title="core.Circuit"><span class="pre">core.Circuit</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">idx</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#core.Circuit.measure" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>Measurement</p>
</div></blockquote>
<p>This method is used to indicate a qubit in the circuit should be
measured.</p>
<p>Parameters:</p>
<ul class="simple">
<li><p><strong>idx</strong> the index of the qubit to be measured [int]</p></li>
</ul>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.Circuit.measure_all">
<span class="sig-name descname"><span class="pre">measure_all</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#core.Circuit" title="core.Circuit"><span class="pre">core.Circuit</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">NUM_QUBITS</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">-</span> <span class="pre">1</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#core.Circuit.measure_all" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>Measure all qubits</p>
</div></blockquote>
<p>This method adds a measurement for all qubits involved in the circuit.</p>
<p>Parameters:</p>
<ul class="simple">
<li><p><strong>NUM_QUBITS</strong> the number of qubits in the circuit [int] [optional, the default value of -1 becomes the output of the XACC nPhysicalBits method.]</p></li>
</ul>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.Circuit.multiplication">
<span class="sig-name descname"><span class="pre">multiplication</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#core.Circuit" title="core.Circuit"><span class="pre">core.Circuit</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">qubit_ancilla</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.int32</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">qubits_a</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.int32</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">qubits_b</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.int32</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">qubits_result</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">is_LSB</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#core.Circuit.multiplication" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>Multiplication</p>
</div></blockquote>
<p>This method adds a Multiplication to the circuit.</p>
<p>Given two inputs a and b, computes the product a*b and stores the result on a new register.</p>
<p>Parameters:</p>
<ul class="simple">
<li><p><strong>qubits_a</strong> the indices of the qubits encoding a [list of int]</p></li>
<li><p><strong>qubits_b</strong> the indices of the qubits encoding b [list of int]</p></li>
<li><p><strong>qubits_result</strong> the indices of the qubits that will ecode the multiplication result [list of int]</p></li>
<li><p><strong>qubits_ancilla</strong> the index of the single required ancilla [int]</p></li>
<li><p><strong>is_LSB</strong> Indicates that the trial scores are encoded with LSB ordering [bool]</p></li>
</ul>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.Circuit.openqasm">
<span class="sig-name descname"><span class="pre">openqasm</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#core.Circuit" title="core.Circuit"><span class="pre">core.Circuit</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">str</span></span></span><a class="headerlink" href="#core.Circuit.openqasm" title="Permalink to this definition"></a></dt>
<dd><p>Get the OpenQASM representation of the circuit.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.Circuit.print">
<span class="sig-name descname"><span class="pre">print</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#core.Circuit" title="core.Circuit"><span class="pre">core.Circuit</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#core.Circuit.print" title="Permalink to this definition"></a></dt>
<dd><p>Print the quantum circuit that has been built</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.Circuit.proper_fraction_division">
<span class="sig-name descname"><span class="pre">proper_fraction_division</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#core.Circuit" title="core.Circuit"><span class="pre">core.Circuit</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">qubits_numerator</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.int32</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">qubits_denominator</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.int32</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">qubits_fraction</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.int32</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">qubits_ancilla</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.int32</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">is_LSB</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">True</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#core.Circuit.proper_fraction_division" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>Proper Fraction Division</p>
</div></blockquote>
<p>This method adds a proper fraction division to the circuit.</p>
<p>Given two inputs num and denom, calculates num/denom and stores the result in a new register, assuming denom &gt; num</p>
<p>Parameters:</p>
<ul class="simple">
<li><p><strong>qubits_numerator</strong> the indices of the qubits encoding the numerator [list of int]</p></li>
<li><p><strong>qubits_denominator</strong> the indices of the qubits encoding the denominator [list of int]</p></li>
<li><p><strong>qubits_fraction</strong> the indices of the qubits that will ecode the division result [list of int]</p></li>
<li><p><strong>qubit_ancilla</strong> the index of the required ancilla [list of int]</p></li>
<li><p><strong>is_LSB</strong> Indicates that the trial scores are encoded with LSB ordering [bool]</p></li>
</ul>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.Circuit.q_prime_unitary">
<span class="sig-name descname"><span class="pre">q_prime_unitary</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#core.Circuit" title="core.Circuit"><span class="pre">core.Circuit</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">nb_qubits_ancilla_metric</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nb_qubits_ancilla_letter</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nb_qubits_next_letter_probabilities</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">nb_qubits_next_letter</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#core.Circuit.q_prime_unitary" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>Q’ Unitary</p>
</div></blockquote>
<p>This method adds a Q’ unitary to the circuit.</p>
<p>Q’ is a unitary required for the quantum decoder algorithm.</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.Circuit.qft">
<span class="sig-name descname"><span class="pre">qft</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#core.Circuit" title="core.Circuit"><span class="pre">core.Circuit</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">qubits</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.int32</span><span class="p"><span class="pre">]</span></span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#core.Circuit.qft" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>Quantum Fourier Transform</p>
</div></blockquote>
<p>This method adds the Quantum Fourier Transform (QFT) to the circuit.
This is a quantum analogue of the discrete Fourier Transform.</p>
<p>Parameters:</p>
<ul class="simple">
<li><p><strong>qubits</strong> the indices of the target qubits [list of int]</p></li>
</ul>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.Circuit.qpe">
<span class="sig-name descname"><span class="pre">qpe</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#core.Circuit" title="core.Circuit"><span class="pre">core.Circuit</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">oracle</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">object</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">precision</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">trial_qubits</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.int32</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">array([],</span> <span class="pre">dtype=int32)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">precision_qubits</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.int32</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">array([],</span> <span class="pre">dtype=int32)</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#core.Circuit.qpe" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>Quantum Phase Estimation</p>
</div></blockquote>
<p>This method adds the Quantum Phase Estimation (QPE) sub-routine to the
circuit.</p>
<p>Given some unitary operator U and and eigenvector v of U, QPE is used to provide a k-bit approximation to
the corresponding eigenvalue’s phase, storing the result in an evaluation register whilst leaving the eigenvector
unchanged.</p>
<p>Parameters:</p>
<ul class="simple">
<li><p><strong>oracle</strong> The unitary operator U involved in the QPE routine [CircuitBuilder]</p></li>
<li><p><strong>precision</strong> The number of bits k used to approximate the phase [int]</p></li>
<li><p><strong>trial_qubits</strong> The indices of the qubits encoding the eigenvector of the unitary [list of int]</p></li>
<li><p><strong>precision_qubits</strong> The indices of the qubits that will be used to store the approximate phase [list of int]</p></li>
</ul>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.Circuit.ripple_add">
<span class="sig-name descname"><span class="pre">ripple_add</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#core.Circuit" title="core.Circuit"><span class="pre">core.Circuit</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">a</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.int32</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">b</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.int32</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">carry_bit</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#core.Circuit.ripple_add" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>Ripple Carry Adder</p>
</div></blockquote>
<p>This method adds a ripple carry adder to the circuit.</p>
<p>The ripple carry adder is an efficient in-line addition operation
with a carry-in bit.</p>
<p>Parameters:</p>
<ul class="simple">
<li><p><strong>a</strong> The qubit indices of the first register in the addition [list of int]</p></li>
<li><p><strong>b</strong> The qubit indices of the second register in the addition. This is where the result of a+b will be stored [list of int]</p></li>
<li><p><strong>carry_bit</strong> The index of the carry-in bit [int]</p></li>
</ul>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.Circuit.run_MLQAE">
<span class="sig-name descname"><span class="pre">run_MLQAE</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#core.Circuit" title="core.Circuit"><span class="pre">core.Circuit</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">state_prep</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">object</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">oracle</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">object</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">is_in_good_subspace</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">Callable</span><span class="p"><span class="pre">[</span></span><span class="p"><span class="pre">[</span></span><span class="pre">str</span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">int</span><span class="p"><span class="pre">]</span></span><span class="p"><span class="pre">,</span></span><span class="w"> </span><span class="pre">int</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">score_qubits</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.int32</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">total_num_qubits</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_runs</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">4</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">shots</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">100</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">qpu</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'qpp'</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">str</span></span></span><a class="headerlink" href="#core.Circuit.run_MLQAE" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>Run Maximum-Likelihood Amplitude Estimation</p>
</div></blockquote>
<p>This method sets up and executes an instance of the maximum-likelihood
amplitude estimation circuit.</p>
<p>Given a state split into a good subspace and a bad subspace, MLQAE is an alternative to canonical QAE to find an estimate for the
amplitude of the good subspace, a. It works by performing several runs
of amplitude amplification with various iterations and recording the
number of good shots measured. Given this data, it finds the value of
a that maximises the likelihood function.</p>
<p>Parameters:</p>
<ul class="simple">
<li><p><strong>state_prep</strong> The circuit A used to prepare the input state [CircuitBuilder]</p></li>
<li><p><strong>oracle</strong> The oracle circuit O that marks the good subspace [CircuitBuilder]</p></li>
<li><p><strong>is_in_good_subspace</strong> A function that, given a measured bitstring and potentially some other input value, returns a 1 if the measurement is in the good subspace and a 0 otherwise. [func(str, int) -&gt; int]</p></li>
<li><p><strong>score_qubits</strong> The indices of the qubits that determine whether the state is in the good or bad subspace [list of int]</p></li>
<li><p><strong>total_num_qubits</strong> The total number of qubits in the circuit [int]</p></li>
<li><p><strong>num_runs</strong> The number of runs of amplitude amplification (~4-6 is usually sufficient)</p></li>
<li><p><strong>shots</strong> The number of shots in each run [int]</p></li>
<li><p><strong>qpu</strong> The name of the accelerator used to execute the circuit [string]</p></li>
</ul>
<p>Returns: The output buffer of the execution</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.Circuit.run_canonical_ae">
<span class="sig-name descname"><span class="pre">run_canonical_ae</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#core.Circuit" title="core.Circuit"><span class="pre">core.Circuit</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">state_prep</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">object</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">grover_op</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">object</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">precision</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_state_prep_qubits</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_trial_qubits</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">precision_qubits</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.int32</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">array([],</span> <span class="pre">dtype=int32)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">trial_qubits</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.int32</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">array([],</span> <span class="pre">dtype=int32)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">qpu</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'qpp'</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">str</span></span></span><a class="headerlink" href="#core.Circuit.run_canonical_ae" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>Run Canonical Amplitude Estimation</p>
</div></blockquote>
<p>This method sets up and executes an instance of the canonical amplitude
estimation circuit.</p>
<p>Parameters:</p>
<ul class="simple">
<li><p><strong>state_prep</strong> The circuit A used to prepare the input state [CircuitBuilder]</p></li>
<li><p><strong>grover_op</strong> The circuit for the Grovers operator Q for the good subspace [CircuitBuilder]</p></li>
<li><p><strong>precision</strong> The number of bits k used to approximate the amplitude [int]</p></li>
<li><p><strong>num_state_prep_qubits</strong> The number of qubits acted on by the state_prep circuit A [int]</p></li>
<li><p><strong>num_trial_qubits</strong> The number of qubits acted on by the grover_op circuit Q [int]</p></li>
<li><p><strong>trial_qubits</strong> The indices of the qubits acted on by the grover_op circuit Q [list of int]</p></li>
<li><p><strong>precision_qubits</strong> The indices of the qubits used to store the approximate amplitude [list of int]</p></li>
<li><p><strong>qpu</strong> The name of the accelerator used to execute the circuit [string]</p></li>
</ul>
<p>Returns: The output buffer of the execution</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.Circuit.run_canonical_ae_with_oracle">
<span class="sig-name descname"><span class="pre">run_canonical_ae_with_oracle</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#core.Circuit" title="core.Circuit"><span class="pre">core.Circuit</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">state_prep</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">object</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">oracle</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">object</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">precision</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_state_prep_qubits</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">num_trial_qubits</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">precision_qubits</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.int32</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">array([],</span> <span class="pre">dtype=int32)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">trial_qubits</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.int32</span><span class="p"><span class="pre">]</span></span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">array([],</span> <span class="pre">dtype=int32)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">qpu</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">str</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">'qpp'</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">str</span></span></span><a class="headerlink" href="#core.Circuit.run_canonical_ae_with_oracle" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>Run Canonical Amplitude Estimation with Oracle</p>
</div></blockquote>
<p>This method sets up and executes an instance of the canonical amplitude
estimation circuit, but instead of providing the grovers_op Q, we
provide the oracle circuit O which marks the good elements.</p>
<p>The Grovvers operator Q is then constructed within the method from O and
the state_prep circuit A.</p>
<p>Parameters:</p>
<ul class="simple">
<li><p><strong>state_prep</strong> The circuit A used to prepare the input state [CircuitBuilder]</p></li>
<li><p><strong>oracle</strong> The oracle circuit O that marks the good subspace [CircuitBuilder]</p></li>
<li><p><strong>precision</strong> The number of bits k used to approximate the amplitude [int]</p></li>
<li><p><strong>num_state_prep_qubits</strong> The number of qubits acted on by the state_prep circuit A [int]</p></li>
<li><p><strong>num_trial_qubits</strong> The number of qubits acted on by the grover_op circuit Q [int]</p></li>
<li><p><strong>precision_qubits</strong> The indices of the qubits used to store the approximate amplitude [list of int]</p></li>
<li><p><strong>trial_qubits</strong> The indices of the qubits acted on by the grover_op circuit Q [list of int]</p></li>
<li><p><strong>qpu</strong> The name of the accelerator used to execute the circuit [string]</p></li>
</ul>
<p>Returns: The output buffer of the execution</p>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.Circuit.rx">
<span class="sig-name descname"><span class="pre">rx</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#core.Circuit" title="core.Circuit"><span class="pre">core.Circuit</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">idx</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">theta</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#core.Circuit.rx" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>RX gate</p>
</div></blockquote>
<p>This method adds an x-axis rotation (RX) gate to the circuit.</p>
<p>Parameters:</p>
<ul class="simple">
<li><p><strong>idx</strong> the index of the qubit being acted on [int]</p></li>
<li><p><strong>theta</strong> the angle of rotation about the x-axis [double]</p></li>
</ul>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.Circuit.ry">
<span class="sig-name descname"><span class="pre">ry</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#core.Circuit" title="core.Circuit"><span class="pre">core.Circuit</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">idx</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">theta</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#core.Circuit.ry" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>RY gate</p>
</div></blockquote>
<p>This method adds a y-axis rotation (RY) gate to the circuit.</p>
<p>Parameters:</p>
<ul class="simple">
<li><p><strong>idx</strong> the index of the qubit being acted on [int]</p></li>
<li><p><strong>theta</strong> the angle of rotation about the y-axis [double]</p></li>
</ul>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.Circuit.rz">
<span class="sig-name descname"><span class="pre">rz</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#core.Circuit" title="core.Circuit"><span class="pre">core.Circuit</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">idx</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">theta</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#core.Circuit.rz" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>RZ gate</p>
</div></blockquote>
<p>This method adds a z-axis rotation (RZ) gate to the circuit.</p>
<p>Parameters:</p>
<ul class="simple">
<li><p><strong>idx</strong> the index of the qubit being acted on [int]</p></li>
<li><p><strong>theta</strong> the angle of rotation about the z-axis [double]</p></li>
</ul>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.Circuit.s">
<span class="sig-name descname"><span class="pre">s</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#core.Circuit" title="core.Circuit"><span class="pre">core.Circuit</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">idx</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#core.Circuit.s" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>S gate</p>
</div></blockquote>
<p>This method adds an S gate to the circuit.</p>
<p>The S gate is defined by its action on the basis states</p>
<p>Parameters:</p>
<ul class="simple">
<li><p><strong>idx</strong> the index of the qubit being acted on [int]</p></li>
</ul>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.Circuit.sdg">
<span class="sig-name descname"><span class="pre">sdg</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#core.Circuit" title="core.Circuit"><span class="pre">core.Circuit</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">idx</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#core.Circuit.sdg" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>Sdg gate</p>
</div></blockquote>
<p>This method adds an inverse of the S gate (Sdg) to the circuit.</p>
<p>Parameters:</p>
<ul class="simple">
<li><p><strong>idx</strong> the index of the qubit being acted on [int]</p></li>
</ul>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.Circuit.subtraction">
<span class="sig-name descname"><span class="pre">subtraction</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#core.Circuit" title="core.Circuit"><span class="pre">core.Circuit</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">qubits_larger</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.int32</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">qubits_smaller</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">numpy.ndarray</span><span class="p"><span class="pre">[</span></span><span class="pre">numpy.int32</span><span class="p"><span class="pre">]</span></span></span></em>, <em class="sig-param"><span class="n"><span class="pre">is_LSB</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">bool</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">True</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">qubit_ancilla</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span><span class="w"> </span><span class="o"><span class="pre">=</span></span><span class="w"> </span><span class="default_value"><span class="pre">-</span> <span class="pre">1</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#core.Circuit.subtraction" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>Subtraction</p>
</div></blockquote>
<p>This method adds a subtraction to the circuit.</p>
<p>Given two inputs a and b, leaves b unchanged but maps a to the difference a-b, assuming a&gt;b.</p>
<p>Parameters:</p>
<ul class="simple">
<li><p><strong>qubits_larger</strong> the indices of the qubits encoding the larger value [list of int]</p></li>
<li><p><strong>qubits_smaller</strong> the indices of the qubits encoding the smaller value [list of int]</p></li>
<li><p><strong>is_LSB</strong> Indicates that the trial scores are encoded with LSB ordering [bool]</p></li>
<li><p><strong>qubit_ancilla</strong> the index of the required ancilla [list of int]</p></li>
</ul>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.Circuit.superposition_adder">
<span class="sig-name descname"><span class="pre">superposition_adder</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self:</span> <span class="pre">core.Circuit</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">q0:</span> <span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">q1:</span> <span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">q2:</span> <span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">qubits_flags:</span> <span class="pre">numpy.ndarray[numpy.int32]</span> <span class="pre">=</span> <span class="pre">array([]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype=int32)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">qubits_string:</span> <span class="pre">numpy.ndarray[numpy.int32]</span> <span class="pre">=</span> <span class="pre">array([]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype=int32)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">qubits_metric:</span> <span class="pre">numpy.ndarray[numpy.int32]</span> <span class="pre">=</span> <span class="pre">array([]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype=int32)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">ae_state_prep_circ:</span> <span class="pre">object</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">qubits_ancilla:</span> <span class="pre">numpy.ndarray[numpy.int32]</span> <span class="pre">=</span> <span class="pre">array([]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype=int32)</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">qubits_beam_metric:</span> <span class="pre">numpy.ndarray[numpy.int32]</span> <span class="pre">=</span> <span class="pre">array([]</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">dtype=int32)</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#core.Circuit.superposition_adder" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>Superposition adder</p>
</div></blockquote>
<p>This method adds a Superposition Adder to the circuit.</p>
<p>Given a superposition state, this circuit computes the mean of the amplitudes of the superposition components.</p>
<p>Parameters:</p>
<ul class="simple">
<li><p><strong>q0</strong> the index of the single required ancilla [int]</p></li>
<li><p><strong>q1</strong> the index of the single required ancilla [int]</p></li>
<li><p><strong>q2</strong> the index of the single required ancilla [int]</p></li>
<li><p><strong>qubits_flags</strong> the indices of the flag qubits [list of int]</p></li>
<li><p><strong>qubits_string</strong> the indices of the qubits encoding the string [list of int]</p></li>
<li><p><strong>qubits_metric</strong> the indices of the qubits encoding the metric value corresponding to the string [list of int]</p></li>
<li><p><strong>ae_state_prep_circ</strong> The circuit A used to prepare the input state [CircuitBuilder]</p></li>
<li><p><strong>qubits_ancilla</strong> the indices of the required ancilla qubits [list of int]</p></li>
<li><p><strong>qubits_beam_metric</strong> the indices of the qubits encoding class’ metric [list of int]</p></li>
</ul>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.Circuit.swap">
<span class="sig-name descname"><span class="pre">swap</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#core.Circuit" title="core.Circuit"><span class="pre">core.Circuit</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">q1</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">q2</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#core.Circuit.swap" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>SWAP gate</p>
</div></blockquote>
<p>This method adds a SWAP gate to the circuit. The SWAP gate is used to swap the quantum state of two qubits.</p>
<p>Parameters:</p>
<ul class="simple">
<li><p><strong>q1</strong> the index of the first qubit [int]</p></li>
<li><p><strong>q2</strong> the index of the second qubit [int]</p></li>
</ul>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.Circuit.t">
<span class="sig-name descname"><span class="pre">t</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#core.Circuit" title="core.Circuit"><span class="pre">core.Circuit</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">idx</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#core.Circuit.t" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>T gate</p>
</div></blockquote>
<p>This method adds a T gate to the circuit.</p>
<p>Parameters:</p>
<ul class="simple">
<li><p><strong>idx</strong> the index of the qubit being acted on [int]</p></li>
</ul>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.Circuit.tdg">
<span class="sig-name descname"><span class="pre">tdg</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#core.Circuit" title="core.Circuit"><span class="pre">core.Circuit</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">idx</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#core.Circuit.tdg" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>Tdg gate</p>
</div></blockquote>
<p>This method adds an inverse of the T gate (Tdg) to the circuit.</p>
<p>The Tdg gate is defined by its action on the basis states</p>
<p>Parameters:</p>
<ul class="simple">
<li><p><strong>idx</strong> the index of the qubit being acted on [int]</p></li>
</ul>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.Circuit.u1">
<span class="sig-name descname"><span class="pre">u1</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#core.Circuit" title="core.Circuit"><span class="pre">core.Circuit</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">idx</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">theta</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#core.Circuit.u1" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>U1 gate</p>
</div></blockquote>
<p>This method adds a phase (U1) gate to the circuit.</p>
<p>Parameters:</p>
<ul class="simple">
<li><p><strong>idx</strong> the index of the qubit being acted on [int]</p></li>
<li><p><strong>theta</strong> the value of the phase [double]</p></li>
</ul>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.Circuit.u3">
<span class="sig-name descname"><span class="pre">u3</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self:</span> <span class="pre">core.Circuit</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">idx:</span> <span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">theta:</span> <span class="pre">float</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">phi:</span> <span class="pre">float</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">lambda:</span> <span class="pre">float</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#core.Circuit.u3" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>U3 gate</p>
</div></blockquote>
<p>This method adds an arbitrary single qubit gate (U3) to the circuit.</p>
<p>Parameters:</p>
<ul class="simple">
<li><p><strong>idx</strong> the index of the qubit being acted on [int]</p></li>
<li><p><strong>theta</strong> [double]</p></li>
<li><p><strong>phi</strong> [double]</p></li>
<li><p><strong>lambda</strong> [double]</p></li>
</ul>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.Circuit.x">
<span class="sig-name descname"><span class="pre">x</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#core.Circuit" title="core.Circuit"><span class="pre">core.Circuit</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">idx</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#core.Circuit.x" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><blockquote>
<div><p>Pauli-X gate</p>
</div></blockquote>
<p>This method adds a Pauli-X (X) gate to the circuit.</p>
<p>The X gate is defined by its action on the basis states</p>
</div></blockquote>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>[</strong><strong>int</strong><strong>]</strong> (<em>- idx the index of the qubit being acted on</em>) – </p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.Circuit.y">
<span class="sig-name descname"><span class="pre">y</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#core.Circuit" title="core.Circuit"><span class="pre">core.Circuit</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">idx</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#core.Circuit.y" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>Pauli-Y gate</p>
</div></blockquote>
<p>This method adds a Pauli-Y (Y) gate to the circuit.</p>
<p>Parameters:</p>
<ul class="simple">
<li><p><strong>idx</strong> the index of the qubit being acted on [int]</p></li>
</ul>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.Circuit.z">
<span class="sig-name descname"><span class="pre">z</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#core.Circuit" title="core.Circuit"><span class="pre">core.Circuit</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">idx</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#core.Circuit.z" title="Permalink to this definition"></a></dt>
<dd><blockquote>
<div><p>Pauli-Z gate</p>
</div></blockquote>
<p>This method adds a Pauli-Z (Z) gate to the circuit.</p>
<p>Parameters:</p>
<ul class="simple">
<li><p><strong>idx</strong> the index of the qubit being acted on [int]</p></li>
</ul>
</dd></dl>

</dd></dl>

</section>
<section id="noise-modelling">
<h2>Noise Modelling<a class="headerlink" href="#noise-modelling" title="Permalink to this headline"></a></h2>
<p>QB Qristal allows an end-user to implement noise models in Python.</p>
<dl class="py class">
<dt class="sig sig-object py" id="core.NoiseModel">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">core.</span></span><span class="sig-name descname"><span class="pre">NoiseModel</span></span><a class="headerlink" href="#core.NoiseModel" title="Permalink to this definition"></a></dt>
<dd><p>Noise model class allowing specification of noise parameters and connectivity for each gate.</p>
<dl class="py class">
<dt class="sig sig-object py" id="core.NoiseModel.QubitConnectivity">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">QubitConnectivity</span></span><a class="headerlink" href="#core.NoiseModel.QubitConnectivity" title="Permalink to this definition"></a></dt>
<dd><p>Type of qubit connectivity</p>
<p>Members:</p>
<blockquote>
<div><p>AllToAll</p>
<p>Custom</p>
</div></blockquote>
<dl class="py property">
<dt class="sig sig-object py" id="core.NoiseModel.QubitConnectivity.name">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">name</span></span><a class="headerlink" href="#core.NoiseModel.QubitConnectivity.name" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.NoiseModel.add_gate_error">
<span class="sig-name descname"><span class="pre">add_gate_error</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.NoiseModel.add_gate_error" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic">
<li><p>add_gate_error(self: core.NoiseModel, arg0: List[core.KrausOperator], arg1: str, arg2: core.N) -&gt; None</p>
<blockquote>
<div><p>Add a gate error channel for a gate operation</p>
<p>Parameters:</p>
<ul class="simple">
<li><p><em>noise_channel</em> Noise channel to be associated with the gate [List(KraussOperator)]</p></li>
<li><p><em>gate_name</em> Name of the gates [String]</p></li>
<li><p><em>qubits</em> Qubit indices of the gate. [qb.core.N]</p></li>
</ul>
</div></blockquote>
</li>
<li><p>add_gate_error(self: core.NoiseModel, arg0: List[core.KrausOperator], arg1: str, arg2: list) -&gt; None</p>
<blockquote>
<div><p>Overload of add_gate_error that takes <em>qubits</em> directly as List(Integer).</p>
</div></blockquote>
</li>
</ol>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.NoiseModel.add_qubit_connectivity">
<span class="sig-name descname"><span class="pre">add_qubit_connectivity</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#core.NoiseModel" title="core.NoiseModel"><span class="pre">core.NoiseModel</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">arg0</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">arg1</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#core.NoiseModel.add_qubit_connectivity" title="Permalink to this definition"></a></dt>
<dd><p>Add a connected qubit pair to the topology model</p>
<p>Parameters:</p>
<ul class="simple">
<li><p><em>q1</em> First qubit index [Integer]</p></li>
<li><p><em>q2</em> Second qubit index [Integer]</p></li>
</ul>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="core.NoiseModel.connectivity">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">connectivity</span></span><a class="headerlink" href="#core.NoiseModel.connectivity" title="Permalink to this definition"></a></dt>
<dd><p>Get connectivity as a list of connected qubit pairs</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="core.NoiseModel.name">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">name</span></span><a class="headerlink" href="#core.NoiseModel.name" title="Permalink to this definition"></a></dt>
<dd><p>The colloquial name of the noise model</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="core.NoiseModel.qobj_basis_gates">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">qobj_basis_gates</span></span><a class="headerlink" href="#core.NoiseModel.qobj_basis_gates" title="Permalink to this definition"></a></dt>
<dd><p>The list of basis gates that the AER QObj will be referring to.</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="core.NoiseModel.qobj_compiler">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">qobj_compiler</span></span><a class="headerlink" href="#core.NoiseModel.qobj_compiler" title="Permalink to this definition"></a></dt>
<dd><p>‘xacc-qobj’ | ‘qristal-qobj’.</p>
<dl class="field-list simple">
<dt class="field-odd">Type</dt>
<dd class="field-odd"><p>The name of the QObj compiler to use with the AER simulator. Valid options</p>
</dd>
</dl>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.NoiseModel.set_qubit_readout_error">
<span class="sig-name descname"><span class="pre">set_qubit_readout_error</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#core.NoiseModel" title="core.NoiseModel"><span class="pre">core.NoiseModel</span></a></span></em>, <em class="sig-param"><span class="n"><span class="pre">arg0</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">arg1</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#core.ReadoutError" title="core.ReadoutError"><span class="pre">core.ReadoutError</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#core.NoiseModel.set_qubit_readout_error" title="Permalink to this definition"></a></dt>
<dd><p>Set the qubit readout error</p>
<p>Parameters:</p>
<ul class="simple">
<li><p><em>qubitIdx</em> Qubit to set [Integer]</p></li>
<li><p><em>ro_error</em> Readout error [ReadoutError]</p></li>
</ul>
</dd></dl>

<dl class="py method">
<dt class="sig sig-object py" id="core.NoiseModel.to_json">
<span class="sig-name descname"><span class="pre">to_json</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><a class="reference internal" href="#core.NoiseModel" title="core.NoiseModel"><span class="pre">core.NoiseModel</span></a></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">str</span></span></span><a class="headerlink" href="#core.NoiseModel.to_json" title="Permalink to this definition"></a></dt>
<dd><p>Convert noise model to json string</p>
</dd></dl>

</dd></dl>

<p>This <cite>NoiseModel</cite> can be constructed from the quantum device <cite>NoiseProperties</cite>.</p>
<dl class="py class">
<dt class="sig sig-object py" id="core.NoiseProperties">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">core.</span></span><span class="sig-name descname"><span class="pre">NoiseProperties</span></span><a class="headerlink" href="#core.NoiseProperties" title="Permalink to this definition"></a></dt>
<dd><dl class="simple">
<dt>Use NoiseProperties to accept user input parameters for custom noise models.  There are 3 types of inputs used for constructing a custom noise model:</dt><dd><ul class="simple">
<li><p>Qubit topology</p></li>
<li><p>Time duration of quantum gate operations</p></li>
<li><p>Parameters for quantum noise channels and classical errors</p></li>
</ul>
</dd>
</dl>
<dl class="py property">
<dt class="sig sig-object py" id="core.NoiseProperties.gate_pauli_errors">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">gate_pauli_errors</span></span><a class="headerlink" href="#core.NoiseProperties.gate_pauli_errors" title="Permalink to this definition"></a></dt>
<dd><p><cite>gate_pauli_errors</cite> is the parameter for gate error derived from randomized benchmarking of a quantum gate operation that is applied at a target set of qubits.</p>
<p>Unit: none (range: [0.0, 1.0])</p>
<p>Code example: 4 qubits: “u3” single-qubit gate, uniform gate error parameter = 0.03 (3%); “cx” between neighboring qubits (on a line), gate error parameter = 0.1 (10%):</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp"># Initialize an empty NoiseProperties</span>
<span class="n">t_qbnp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">NoiseProperties</span><span class="p">()</span>
<span class="n">t_qbnp</span><span class="p">.</span><span class="n">gate_pauli_errors</span><span class="p">[</span><span class="s">&quot;u3&quot;</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{}</span>
<span class="n">t_qbnp</span><span class="p">.</span><span class="n">gate_pauli_errors</span><span class="p">[</span><span class="s">&quot;cx&quot;</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{}</span>
<span class="n">num_qubits</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">4</span>
<span class="k">for</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="n">range</span><span class="p">(</span><span class="n">num_qubits</span><span class="p">)</span><span class="o">:</span>
<span class="w">  </span><span class="n">t_qbnp</span><span class="p">.</span><span class="n">gate_pauli_errors</span><span class="p">[</span><span class="s">&quot;u3&quot;</span><span class="p">][[</span><span class="n">i</span><span class="p">]]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.03</span>
<span class="w">  </span><span class="cp"># Qubits on a line:</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">num_qubits</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="o">:</span>
<span class="w">    </span><span class="n">t_qbnp</span><span class="p">.</span><span class="n">gate_pauli_errors</span><span class="p">[</span><span class="s">&quot;cx&quot;</span><span class="p">][[</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">]]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.1</span>

<span class="cp"># Print out the gate error map:</span>
<span class="n">print</span><span class="p">(</span><span class="n">t_qbnp</span><span class="p">.</span><span class="n">gate_pauli_errors</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="core.NoiseProperties.gate_time_us">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">gate_time_us</span></span><a class="headerlink" href="#core.NoiseProperties.gate_time_us" title="Permalink to this definition"></a></dt>
<dd><p><cite>gate_time_us</cite> is the duration for a quantum gate operation when applied at a target set of qubits.</p>
<p>Unit: microseconds</p>
<p>Code example: 4 qubits: “u3” single-qubit gate, uniform duration of 5.2us; “cx” between neighboring qubits (on a line), uniform duration of 20us:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp"># Initialize an empty NoiseProperties</span>
<span class="n">t_qbnp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">NoiseProperties</span><span class="p">()</span>
<span class="n">t_qbnp</span><span class="p">.</span><span class="n">gate_time_us</span><span class="p">[</span><span class="s">&quot;u3&quot;</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{}</span>
<span class="n">t_qbnp</span><span class="p">.</span><span class="n">gate_time_us</span><span class="p">[</span><span class="s">&quot;cx&quot;</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">{}</span>
<span class="n">num_qubits</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mi">4</span>
<span class="k">for</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="n">range</span><span class="p">(</span><span class="n">num_qubits</span><span class="p">)</span><span class="o">:</span>
<span class="w">  </span><span class="n">t_qbnp</span><span class="p">.</span><span class="n">gate_time_us</span><span class="p">[</span><span class="s">&quot;u3&quot;</span><span class="p">][[</span><span class="n">i</span><span class="p">]]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">5.2</span>
<span class="w">  </span><span class="cp"># Qubits on a line:</span>
<span class="w">  </span><span class="k">if</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">!=</span><span class="w"> </span><span class="n">num_qubits</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="mi">1</span><span class="o">:</span>
<span class="w">    </span><span class="n">t_qbnp</span><span class="p">.</span><span class="n">gate_time_us</span><span class="p">[</span><span class="s">&quot;cx&quot;</span><span class="p">][[</span><span class="n">i</span><span class="p">,</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="mi">1</span><span class="p">]]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">20.0</span>

<span class="cp"># Print out the gate time map:</span>
<span class="n">print</span><span class="p">(</span><span class="n">t_qbnp</span><span class="p">.</span><span class="n">gate_time_us</span><span class="p">)</span>
</pre></div>
</div>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="core.NoiseProperties.qubit_topology">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">qubit_topology</span></span><a class="headerlink" href="#core.NoiseProperties.qubit_topology" title="Permalink to this definition"></a></dt>
<dd><p><cite>qubit_topology</cite> is a graph comprised of directed edges {control qubit, target qubit} with control qubit as the source of the edge -&gt; target qubit as the destination of the edge.</p>
<p>Code example: “cx” symmetrical two-qubit gate with 4 qubits in the topology below:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp"># Topology</span>
<span class="cp">#    q0 &lt;--cx--&gt; q1</span>
<span class="cp">#     ^           ^</span>
<span class="cp">#     |           |</span>
<span class="cp">#     cx          cx</span>
<span class="cp">#     |           |</span>
<span class="cp">#     v           v</span>
<span class="cp">#    q3 &lt;--cx--&gt; q2</span>
<span class="cp"># Initialize an empty NoiseProperties</span>
<span class="n">t_qbnp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">NoiseProperties</span><span class="p">()</span>
<span class="n">t_qbnp</span><span class="p">.</span><span class="n">qubit_topology</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="p">[[</span><span class="mi">0</span><span class="p">,</span><span class="w"> </span><span class="mi">1</span><span class="p">],</span><span class="w"> </span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="w"> </span><span class="mi">2</span><span class="p">],</span><span class="w"> </span><span class="p">[</span><span class="mi">2</span><span class="p">,</span><span class="w"> </span><span class="mi">3</span><span class="p">],</span><span class="w"> </span><span class="p">[</span><span class="mi">3</span><span class="p">,</span><span class="w"> </span><span class="mi">0</span><span class="p">]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="core.NoiseProperties.readout_errors">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">readout_errors</span></span><a class="headerlink" href="#core.NoiseProperties.readout_errors" title="Permalink to this definition"></a></dt>
<dd><p><cite>readout_errors</cite> is the <em>classical readout error</em> (off-diagonal elements of the confusion matrix).</p>
<p>For a qubit register, with individual qubits zero-indexed by i, <cite>readout_errors</cite> is a map from qubit[i] -&gt; <cite>ReadoutError[i]</cite>.</p>
<p>Unit: none (quantities are probabilities).</p>
<p>Code example: 4-qubit device: 2 qubits (Q0 and Q1) with p(0|1) = p(1|0) = 0.05,
2 qubits (Q2 and Q3) with p(0|1) = 0.1 and p(1|0) = 0.08:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp"># Initialize an empty NoiseProperties</span>
<span class="n">t_qbnp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">NoiseProperties</span><span class="p">()</span>
<span class="n">t_qbnpro_balanced</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ReadoutError</span><span class="p">()</span>
<span class="n">t_qbnpro_balanced</span><span class="p">.</span><span class="n">p_01</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.05</span>
<span class="n">t_qbnpro_balanced</span><span class="p">.</span><span class="n">p_10</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.05</span>
<span class="n">t_qbnpro_asym</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">ReadoutError</span><span class="p">()</span>
<span class="n">t_qbnpro_asym</span><span class="p">.</span><span class="n">p_01</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.10</span>
<span class="n">t_qbnpro_asym</span><span class="p">.</span><span class="n">p_10</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="mf">0.08</span>
<span class="cp"># Q0 and Q1 readout errors</span>
<span class="n">t_qbnp</span><span class="p">.</span><span class="n">readout_errors</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">t_qbnpro_balanced</span>
<span class="n">t_qbnp</span><span class="p">.</span><span class="n">readout_errors</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">t_qbnpro_balanced</span>
<span class="cp"># Q2 and Q3 readout errors</span>
<span class="n">t_qbnp</span><span class="p">.</span><span class="n">readout_errors</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">t_qbnpro_asym</span>
<span class="n">t_qbnp</span><span class="p">.</span><span class="n">readout_errors</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">t_qbnpro_asym</span>
</pre></div>
</div>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="core.NoiseProperties.t1_us">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">t1_us</span></span><a class="headerlink" href="#core.NoiseProperties.t1_us" title="Permalink to this definition"></a></dt>
<dd><p><span class="math notranslate nohighlight">\(T_1\)</span> is the <em>qubit relaxation time</em>.</p>
<p>For a qubit register, with individual qubits zero-indexed by <cite>i</cite>; <cite>t1_us</cite> is a map from qubit[i] -&gt; T1[i].</p>
<p>Unit: microseconds</p>
<p>Code example: 4 qubits all with T1 = 1.5us:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp"># Initialize an empty NoiseProperties</span>
<span class="n">t_qbnp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">NoiseProperties</span><span class="p">()</span>
<span class="cp"># Set T1 of qubits (all with 1.5 us)</span>
<span class="k">for</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="n">range</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span><span class="o">:</span>
<span class="w">  </span><span class="n">t_qbnp</span><span class="p">.</span><span class="n">t1_us</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w">  </span><span class="mf">1.5</span>
</pre></div>
</div>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="core.NoiseProperties.t2_us">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">t2_us</span></span><a class="headerlink" href="#core.NoiseProperties.t2_us" title="Permalink to this definition"></a></dt>
<dd><p><span class="math notranslate nohighlight">\(T_2\)</span> is the <em>qubit dephasing time</em>.</p>
<p>For a qubit register, with individual qubits zero-indexed by <cite>i</cite>; <cite>t2_us</cite> is a map from qubit[i] -&gt; T2[i].</p>
<p>Unit: microseconds</p>
<p>Code example: 4 qubits all with T2 = 0.15us:</p>
<div class="highlight-cpp notranslate"><div class="highlight"><pre><span></span><span class="cp"># Initialize an empty NoiseProperties</span>
<span class="n">t_qbnp</span><span class="w"> </span><span class="o">=</span><span class="w"> </span><span class="n">NoiseProperties</span><span class="p">()</span>
<span class="cp"># Set T2 of qubits (all with 0.15 us)</span>
<span class="k">for</span><span class="w"> </span><span class="n">i</span><span class="w"> </span><span class="n">in</span><span class="w"> </span><span class="n">range</span><span class="p">(</span><span class="mi">4</span><span class="p">)</span><span class="o">:</span>
<span class="w">  </span><span class="n">t_qbnp</span><span class="p">.</span><span class="n">t2_us</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="w"> </span><span class="o">=</span><span class="w">  </span><span class="mf">0.15</span>
</pre></div>
</div>
</dd></dl>

</dd></dl>

<p>Additionally, users can use these builtin classes to construct commonly-used noise channels when building the <cite>NoiseModel</cite>.</p>
<dl class="py class">
<dt class="sig sig-object py" id="core.AmplitudeDampingChannel">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">core.</span></span><span class="sig-name descname"><span class="pre">AmplitudeDampingChannel</span></span><a class="headerlink" href="#core.AmplitudeDampingChannel" title="Permalink to this definition"></a></dt>
<dd><p>Amplitude damping channel factory</p>
<dl class="py method">
<dt class="sig sig-object py" id="core.AmplitudeDampingChannel.Create">
<span class="sig-name descname"><span class="pre">Create</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">arg0</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">List</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="#core.KrausOperator" title="core.KrausOperator"><span class="pre">core.KrausOperator</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#core.AmplitudeDampingChannel.Create" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="core.PhaseDampingChannel">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">core.</span></span><span class="sig-name descname"><span class="pre">PhaseDampingChannel</span></span><a class="headerlink" href="#core.PhaseDampingChannel" title="Permalink to this definition"></a></dt>
<dd><p>Phase damping channel factory</p>
<dl class="py method">
<dt class="sig sig-object py" id="core.PhaseDampingChannel.Create">
<span class="sig-name descname"><span class="pre">Create</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">arg0</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">List</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="#core.KrausOperator" title="core.KrausOperator"><span class="pre">core.KrausOperator</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#core.PhaseDampingChannel.Create" title="Permalink to this definition"></a></dt>
<dd></dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="core.DepolarizingChannel">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">core.</span></span><span class="sig-name descname"><span class="pre">DepolarizingChannel</span></span><a class="headerlink" href="#core.DepolarizingChannel" title="Permalink to this definition"></a></dt>
<dd><p>Depolarizing channel factory</p>
<dl class="py method">
<dt class="sig sig-object py" id="core.DepolarizingChannel.Create">
<span class="sig-name descname"><span class="pre">Create</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="o"><span class="pre">*</span></span><span class="n"><span class="pre">args</span></span></em>, <em class="sig-param"><span class="o"><span class="pre">**</span></span><span class="n"><span class="pre">kwargs</span></span></em><span class="sig-paren">)</span><a class="headerlink" href="#core.DepolarizingChannel.Create" title="Permalink to this definition"></a></dt>
<dd><p>Overloaded function.</p>
<ol class="arabic">
<li><p>Create(self: int, arg0: float) -&gt; List[core.KrausOperator]</p>
<blockquote>
<div><p>Create single-qubit depolarizing channel (balanced/symmetric)</p>
<p>Parameters:</p>
<ul class="simple">
<li><p><em>q</em> Qubit index</p></li>
<li><p><em>p</em> Total depolarizing probability</p></li>
</ul>
</div></blockquote>
</li>
<li><p>Create(self: int, arg0: int, arg1: float) -&gt; List[core.KrausOperator]</p>
<blockquote>
<div><p>Create two-qubit depolarizing channel (balanced/symmetric)</p>
<p>Parameters:</p>
<ul class="simple">
<li><p><em>q1</em> First qubit</p></li>
<li><p><em>q2</em> Second qubit</p></li>
<li><p><em>p</em> Total depolarizing probability</p></li>
</ul>
</div></blockquote>
</li>
</ol>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="core.GeneralizedPhaseAmplitudeDampingChannel">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">core.</span></span><span class="sig-name descname"><span class="pre">GeneralizedPhaseAmplitudeDampingChannel</span></span><a class="headerlink" href="#core.GeneralizedPhaseAmplitudeDampingChannel" title="Permalink to this definition"></a></dt>
<dd><p>Generalized Single-qubit combined phase and amplitude damping quantum error channel</p>
<dl class="py method">
<dt class="sig sig-object py" id="core.GeneralizedPhaseAmplitudeDampingChannel.Create">
<span class="sig-name descname"><span class="pre">Create</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">arg0</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">arg1</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">arg2</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">List</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="#core.KrausOperator" title="core.KrausOperator"><span class="pre">core.KrausOperator</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#core.GeneralizedPhaseAmplitudeDampingChannel.Create" title="Permalink to this definition"></a></dt>
<dd><p>Create a generalized amplitude and phase damping channel</p>
<p>Parameters:</p>
<ul class="simple">
<li><p><em>q</em> Qubit</p></li>
<li><p><em>excited_state_population</em> Excited state population</p></li>
<li><p><em>param_amp</em> Amplitude damping parameter</p></li>
<li><p><em>param_phase</em> Phase damping parameter</p></li>
</ul>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="core.GeneralizedAmplitudeDampingChannel">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">core.</span></span><span class="sig-name descname"><span class="pre">GeneralizedAmplitudeDampingChannel</span></span><a class="headerlink" href="#core.GeneralizedAmplitudeDampingChannel" title="Permalink to this definition"></a></dt>
<dd><p>Generalized amplitude damping quantum error channel</p>
<dl class="py method">
<dt class="sig sig-object py" id="core.GeneralizedAmplitudeDampingChannel.Create">
<span class="sig-name descname"><span class="pre">Create</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">int</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">arg0</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">arg1</span></span><span class="p"><span class="pre">:</span></span><span class="w"> </span><span class="n"><span class="pre">float</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">List</span><span class="p"><span class="pre">[</span></span><a class="reference internal" href="#core.KrausOperator" title="core.KrausOperator"><span class="pre">core.KrausOperator</span></a><span class="p"><span class="pre">]</span></span></span></span><a class="headerlink" href="#core.GeneralizedAmplitudeDampingChannel.Create" title="Permalink to this definition"></a></dt>
<dd><p>Create a generalized amplitude damping channel</p>
<p>Parameters:</p>
<ul class="simple">
<li><p><em>q</em> Qubit</p></li>
<li><p><em>excited_state_population</em> Excited state population</p></li>
<li><p><em>param_amp</em> Amplitude damping parameter</p></li>
</ul>
</dd></dl>

</dd></dl>

<dl class="py class">
<dt class="sig sig-object py" id="core.ReadoutError">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">core.</span></span><span class="sig-name descname"><span class="pre">ReadoutError</span></span><a class="headerlink" href="#core.ReadoutError" title="Permalink to this definition"></a></dt>
<dd><p>Probabilities of reading out a value for a qubit that does not reflect its true state.</p>
<dl class="py property">
<dt class="sig sig-object py" id="core.ReadoutError.p_01">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">p_01</span></span><a class="headerlink" href="#core.ReadoutError.p_01" title="Permalink to this definition"></a></dt>
<dd><p>Classical probability of detecting 0 whereas the true state was <span class="math notranslate nohighlight">\(|1\rangle\)</span></p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="core.ReadoutError.p_10">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">p_10</span></span><a class="headerlink" href="#core.ReadoutError.p_10" title="Permalink to this definition"></a></dt>
<dd><p>Classical probability of detecting 1 whereas the true state was <span class="math notranslate nohighlight">\(|0\rangle\)</span></p>
</dd></dl>

</dd></dl>

<p>In case no builtin noise channels are available for your use case, a fully-customized noise channel can be constructed in terms of instances of the <cite>KrausOperator</cite> class.</p>
<dl class="py class">
<dt class="sig sig-object py" id="core.KrausOperator">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">core.</span></span><span class="sig-name descname"><span class="pre">KrausOperator</span></span><a class="headerlink" href="#core.KrausOperator" title="Permalink to this definition"></a></dt>
<dd><dl class="py property">
<dt class="sig sig-object py" id="core.KrausOperator.matrix">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">matrix</span></span><a class="headerlink" href="#core.KrausOperator.matrix" title="Permalink to this definition"></a></dt>
<dd><p>Kraus matrix</p>
</dd></dl>

<dl class="py property">
<dt class="sig sig-object py" id="core.KrausOperator.qubits">
<em class="property"><span class="pre">property</span><span class="w"> </span></em><span class="sig-name descname"><span class="pre">qubits</span></span><a class="headerlink" href="#core.KrausOperator.qubits" title="Permalink to this definition"></a></dt>
<dd><p>Qubits that this Kraus operator acts on.</p>
</dd></dl>

</dd></dl>

</section>
<section id="placement">
<h2>Placement<a class="headerlink" href="#placement" title="Permalink to this headline"></a></h2>
<p>Qristal contains placement methods to perform mapping from program (logical) qubits to device (physical) qubits satisfying qubit connectivity constraints.</p>
<section id="noise-aware-placement">
<h3>Noise-aware placement<a class="headerlink" href="#noise-aware-placement" title="Permalink to this headline"></a></h3>
<p>The <cite>noise_aware_placement_pass</cite> takes into account gate error rates and readout errors to find the best placement map.</p>
<dl class="py class">
<dt class="sig sig-object py" id="core.noise_aware_placement_pass">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">core.</span></span><span class="sig-name descname"><span class="pre">noise_aware_placement_pass</span></span><a class="headerlink" href="#core.noise_aware_placement_pass" title="Permalink to this definition"></a></dt>
<dd><p>The noise_aware_placement_pass class uses device connectivity, gate errors (1-q and 2-q) and readout errors to find the best placement map.</p>
<dl class="py method">
<dt class="sig sig-object py" id="core.noise_aware_placement_pass.apply">
<span class="sig-name descname"><span class="pre">apply</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self:</span> <span class="pre">core.noise_aware_placement_pass</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">circuit:</span> <span class="pre">qb::CircuitBuilder</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#core.noise_aware_placement_pass.apply" title="Permalink to this definition"></a></dt>
<dd><p>Apply noise-aware placement on the input circuit.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>circuit</strong> – Circuit to be placed (map qubit indices and inject SWAP gates as necessary)</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

<p>Device configuration for the noise-aware placement is defined by <cite>noise_aware_placement_config</cite>.</p>
<dl class="py class">
<dt class="sig sig-object py" id="core.noise_aware_placement_config">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">core.</span></span><span class="sig-name descname"><span class="pre">noise_aware_placement_config</span></span><a class="headerlink" href="#core.noise_aware_placement_config" title="Permalink to this definition"></a></dt>
<dd><p>The noise_aware_placement_config class encapsulates generic backend information required by the noise-aware placement pass.</p>
</dd></dl>

</section>
<section id="swap-based-placement">
<h3>Swap-based placement<a class="headerlink" href="#swap-based-placement" title="Permalink to this headline"></a></h3>
<p>The <cite>swap_placement_pass</cite> performs circuit placement by swapping qubits (along the shortest possible path) when there are gates between uncoupled qubits.</p>
<dl class="py class">
<dt class="sig sig-object py" id="core.swap_placement_pass">
<em class="property"><span class="pre">class</span><span class="w"> </span></em><span class="sig-prename descclassname"><span class="pre">core.</span></span><span class="sig-name descname"><span class="pre">swap_placement_pass</span></span><a class="headerlink" href="#core.swap_placement_pass" title="Permalink to this definition"></a></dt>
<dd><p>Circuit placement pass based on injection of SWAP gates to satisfy device connectivity topology.</p>
<dl class="py method">
<dt class="sig sig-object py" id="core.swap_placement_pass.apply">
<span class="sig-name descname"><span class="pre">apply</span></span><span class="sig-paren">(</span><em class="sig-param"><span class="n"><span class="pre">self:</span> <span class="pre">core.swap_placement_pass</span></span></em>, <em class="sig-param"><span class="n"><span class="pre">circuit:</span> <span class="pre">qb::CircuitBuilder</span></span></em><span class="sig-paren">)</span> <span class="sig-return"><span class="sig-return-icon">&#x2192;</span> <span class="sig-return-typehint"><span class="pre">None</span></span></span><a class="headerlink" href="#core.swap_placement_pass.apply" title="Permalink to this definition"></a></dt>
<dd><p>Apply SWAP-based placement on the input circuit.</p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><p><strong>circuit</strong> – Circuit to be placed (map qubit indices and inject SWAP gates as necessary)</p>
</dd>
</dl>
</dd></dl>

</dd></dl>

</section>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="../_cpp_api/typedef_circuit__builder_8hpp_1a3a836b4117e2cd67fc1980ad99cb2443.html" class="btn btn-neutral float-left" title="Typedef qb::StatePrepFuncCType" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>&#169; Copyright 2023, Quantum Brilliance Pty Ltd.</p>
  </div>

   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>